group AsyncSupport : cplusplus;

header(interfaceName, taskDefs) ::= <<
#ifndef _$interfaceName;format="toUpper"$_ASYNC_SUPPORT_H_
#define _$interfaceName;format="toUpper"$_ASYNC_SUPPORT_H_

$doNotEditC()$

#include "client/AsyncTask.h"

$taskDefs; separator=";\n"$$if(taskDefs)$;$endif$

#endif // _$interfaceName$_ASYNC_SUPPORT_H_
>>

taskHeader(interfaceName, name) ::= <<

class $interfaceName$_$name$Task : public eProsima::DDSRPC::AsyncTask
{
    public:

        /// \brief The default constructor.
        $interfaceName$_$name$Task($interfaceName$_$name$ &obj,
           eProsima::DDSRPC::Client *client);

        /// \brief The default destructor.
        virtual ~$interfaceName$_$name$Task();
        
        virtual void execute(eProsima::DDSRPC::ReturnMessage);
        
        $interfaceName$_$name$& getObject();
        
        private:
        
           $interfaceName$_$name$ &m_obj;
}
>>

definition(opendds, interfaceName, taskDecls) ::= <<
#include "$interfaceName$Proxy.h"
#include "$interfaceName$AsyncSupport.h"
$if(!opendds)$
#include "$interfaceName$RequestReplyPlugin.h"
$else$
#include "$interfaceName$RequestReplyTypeSupportImpl.h"
$endif$

$taskDecls; separator="\n"$
>>

taskDeclaration(opendds, interfaceName, name,inoutParams,outputParams) ::= <<

$interfaceName$_$name$Task::$interfaceName$_$name$Task($interfaceName$_$name$ &obj,
   eProsima::DDSRPC::Client *client) : AsyncTask(client), m_obj(obj)
{
$if(!opendds)$
    m_reply = (void*)$name$ReplyTypeSupport::create_data();
$else$
    m_reply = (void*)new $name$Reply();
$endif$
}

$interfaceName$_$name$Task::~$interfaceName$_$name$Task()
{
$if(!opendds)$
    $name$ReplyTypeSupport::delete_data(($name$Reply*)m_reply);
$else$
    delete ($name$Reply*)m_reply;
$endif$
}

$interfaceName$_$name$& $interfaceName$_$name$Task::getObject()
{
    return m_obj;
}

void $interfaceName$_$name$Task::execute(eProsima::DDSRPC::ReturnMessage message)
{
    $inoutParams:{$varDecl(opendds=opendds, type = it.type, name = it.name, create="yes", string = it.string)$}; separator="\n"$   
    $outputParams:{$varDecl(opendds=opendds, type = it.type, name = it.name, create="yes", string = it.string)$}; separator="\n"$ 
	
	if(message == eProsima::DDSRPC::OPERATION_SUCCESSFUL)
	{
		$name$ReplyUtils::extractTypeData(($name$Reply*)m_reply$if([inoutParams, outputParams])$, $extractTypeDataParams(inoutParams=inoutParams, outputParams=outputParams)$$endif$);
		getObject().$name$($extractTypeDataParams(inoutParams=inoutParams, outputParams=outputParams)$);
	}
	else
	{
	    getObject().error(message);
	}
}

>>

/**
 * extractTypeDataParams: Internal Template
 * Produces the params for calling RequestUtils extractTypeData method 
 * Params:
 *   inoutParams  : list of inout params objects.
 *   outputParams : list of output params objects.
 *
 * Uses:
 *  nextExtractParam - local
 */ 
extractTypeDataParams(inoutParams, outputParams) ::= <<
$[nextExtractParam(params=inoutParams),nextExtractParam(previous=inoutParams, params=outputParams)]$
>>

/**
 * nextExtractParam: Internal Template
 * Adds arguments to a function call preceeding them by a comma
 * if there are previous arguments. 
 * Params:
 *   previous   : List of previous arguments in the function call. Nullable.
 *   params     : List of next arguments in the function call. Nullable.
 *
 * Uses:
 */ 
 nextExtractParam(previous, params) ::= <<
$if(previous)$
$if(params)$,
$endif$
$endif$
$params:{$varExtractUse(type = it.type, name = it.name)$};separator=", "$
>>

/**
 * varExtractUse: Internal Template
 * Uses the variable as a parameter to a funcion call 
 * checking if ti is a pointer or not. 
 * Params:
 *   type     : Variable type.
 *   name     : Variable name. 
 *
 * Uses:
 */ 
 varExtractUse(type, name) ::= <<
$if(typeInitMap.(type))$$name$
$else$
$name$
$endif$    
>>