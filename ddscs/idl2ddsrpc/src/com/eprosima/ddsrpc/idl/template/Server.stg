/* $Id$   *
 * (c) Copyright, eProsima, 2009.                                          *
 * All rights reserved.                                                    *    
 *                                                                         *
 * No duplications, whole or partial, manual or electronic, may be made    *
 * without express written permission.  Any such copies, or                *
 * revisions thereof, must display this notice unaltered.                  *
 * This code contains trade secrets of                                     *
 * eProsima (Proyectos y Sistemas de Mantenimiento S.L.)                   *
 *                                                                         *
 * modification history                                                    *
 * --------------------                                                    *
 * 1.0,29sep09,RodM Created                                                *
 * =====================================================================   *
 */

group Server;

/************************************************************************
 *                                                                      *
 *   External Templates: Common Templates for C++ code generation       *
 *                                                                      *
 ************************************************************************
 */
/**
 * headerServer: External Template
 * Produces header file for a Server that handles requests and replies for an object that 
 * implements the interface defined in IDL.
 * 
 * Params:
 *   interfaceName : name of the interface.
 *   funNames      : List with the names of the interface methods.
 *   funDecls      : List whith the function headers - produced by 
 *                   exFunctionHeader template.
 *
 * Uses:
 *   include    - inherited(cplusplus)
 *   doNotEditC - inherited(cplusplus)
 */ 
headerServer(interfaceName, funNames, funDecls) ::= <<
#ifndef _$interfaceName;format="toUpper"$SKELETON_H_
#define _$interfaceName;format="toUpper"$SKELETON_H_

$doNotEditC()$

#include "server/Server.h"
#include "$interfaceName$ServerImpl.h"
#include "$interfaceName$RequestReplyUtils.h"

class $interfaceName$ServerH : public eProsima::DDSRPC::Server
{
    private: 
      $interfaceName$ServerImpl *_impl;
    public:

        /// \brief The default constructor.
        $interfaceName$ServerH(eProsima::DDSRPC::ServerStrategy *strategy, eProsima::DDSRPC::Transport *transport,
            int domainId = 0);

        /// \brief The default destructor.
        virtual ~$interfaceName$ServerH();

        $funDecls; separator=";\n"$;
};

class $interfaceName$Server : public $interfaceName$ServerH
{
    public:

        /// \brief The default constructor.
        $interfaceName$Server(eProsima::DDSRPC::ServerStrategy *strategy,
            int domainId = 0);

        /// \brief The default destructor.
        virtual ~$interfaceName$Server();
};

class $interfaceName$WANServer : public $interfaceName$ServerH
{
    public:

        /// \brief The default constructor.
        $interfaceName$WANServer(eProsima::DDSRPC::ServerStrategy *strategy, 
            const char *public_address, const char *server_bind_port,
            int domainId = 0);

        /// \brief The default destructor.
        virtual ~$interfaceName$WANServer();
};

#endif // _$interfaceName$SKELETON_H_
>>

/**
 * headerImpl: External Template
 * Produces header file for a class that implements the interface defined in IDL.
 * 
 * Params:
 *   interfaceName : name of the interface.
 *   funNames      : List with the names of the interface methods.
 *   funDecls      : List whith the function headers - produced by 
 *                   inherited functionHeader template.
 *
 * Uses:
 *   doNotEditC - inherited(cplusplus)
 */ 
headerImpl(interfaceName, funNames, funDecls) ::= <<
#ifndef _$interfaceName;format="toUpper"$SERVER_IMPL_H_
#define _$interfaceName;format="toUpper"$SERVER_IMPL_H_

$doNotEditC()$

#include "utils/Messages.h"
#include "$interfaceName$RequestReplyUtils.h"

class $interfaceName$ServerImpl
{
    public:

        /// \brief The default constructor.
        $interfaceName$ServerImpl();

        /// \brief The default destructor.
        virtual ~$interfaceName$ServerImpl();

        $funDecls; separator=";\n"$;
};

#endif // _$interfaceName$SERVER_IMPL_H_
>>

/**
 * emptyFunctionImpl: External Template
 * Empty implementation for a function. To be filled with user application code.
 * Params:
 *   interfaceName: Name of the interface whose this function belongs to.
 *   type:         function return type.
 *   name:         function name. 
 *   inputParams:  list of input params objects.
 *   inoutParams:  list of inout params objects.
 *   outputParams: list of output params objects.
 *
 * Uses:
 *  functionHeader - inherited(cplusplus)
 *  returnType     - local
 */ 
emptyFunctionImpl(interfaceName,type,name,inputParams,inoutParams,outputParams,isOneway) ::= <<
$functionHeader(class={$interfaceName$ServerImpl},...)$ 
{
  eProsima::DDSRPC::ReturnMessage retCode = eProsima::DDSRPC::OPERATION_SUCCESSFUL;
  
  return retCode;
} 
>>

/**
 * functionImpl: External Template
 * Produces the code required to handle a request: 
 * Extracts request Data to local variables and use them to call implementation object.
 * Creates a reply Data object and fills it with the output values and sends it 
 *
 * Params:
 *   interfaceName: Name of the interface whose this function belongs to.
 *   type:         function return type.
 *   name:         function name. 
 *   inputParams:  list of input params objects.
 *   inoutParams:  list of inout params objects.
 *   outputParams: list of output params objects.
 *
 * Uses:
 *  varDecl               - inherited(cplusplus)
 *  nextParam             - inherited(cplusplus)
 *  lastParam             - inherited(cplusplus)
 *  extractTypeDataParams - inherited(cplusplus)
 */ 
functionImpl(interfaceName,type,name,string,inputParams,inoutParams,outputParams,isOneway) ::= <<
$exFunctionHeader(class=interfaceName,...)$ 
{ 
    $interfaceName$ServerH *srv = dynamic_cast<$interfaceName$ServerH*>(server);
    $inputParams:{$varDecl(type = it.type, name = it.name, string = it.string)$}; separator="\n"$   
    $inoutParams:{$varDecl(type = it.type, name = it.name, create="yes", string = it.string)$}; separator="\n"$   
    $outputParams:{$varDecl(type = it.type, name = it.name, create="yes", string = it.string)$}; separator="\n"$   
    $varDecl(type=type, name="returnedValue")$    
    $if(!isOneway)$$name$Reply *replyData = NULL;$endif$

    $name$RequestUtils::extractTypeData(($name$Request*)requestData$if([inputParams,inoutParams])$, $extractTypeDataParams(type=type,...)$$endif$);
                                         
    $if(!voidInitMap.(type))$
    returnedValue = $endif$srv->_impl->$name$($nextParam(params=inputParams)$$nextParam(previous=inputParams, params=inoutParams)$$nextParam(previous=[inputParams,inoutParams], params=outputParams)$);
           
    $if(!isOneway)$
    replyData = $name$ReplyUtils::createTypeData($nextParam(params=inoutParams)$$nextParam(previous=inoutParams, params=outputParams)$);
                                                  
    // sendReply takes care of deleting the data
    service->sendReply(requestData, replyData, returnedValue);
    
    $reqrepDestruction(type=name, reqrep="Reply", name="replyData")$
    $endif$
    
    $reqrepDestruction(type=name, reqrep="Request", name="requestData", void="void")$
    
    $inoutParams:{$varDel(type = it.type, name = it.name, string = it.string)$}; separator="\n"$
    $outputParams:{$varDel(type = it.type, name = it.name, string = it.string)$}; separator="\n"$
}
>>

/**
 * definitionServer: External Template
 * Produces the Server implementation file.
 * Params:
 *   interfaceName: Name of the interface whose methods this proxy invokes.
 *   funNames     : list of the interface function names. 
 *   funImpls     : list of functionImpl template outputs.
 *
 * Uses:
 *   doNotEditC - inherited(cplusplus)
 *   createRPC - local
 */ 
definitionServer(interfaceName, funNames, funImpls) ::= <<
$doNotEditC()$

#include "$interfaceName$Server.h"
#include "transports/UDPTransport.h"
#include "transports/TCPTransport.h"
$ReqRepIncludes(interfaceName=interfaceName)$

#include "$interfaceName$ServerRPCSupport.h"

$interfaceName$ServerH::$interfaceName$ServerH(eProsima::DDSRPC::ServerStrategy *strategy,
    eProsima::DDSRPC::Transport *transport, int domainId) :
    Server(strategy, transport, domainId)
{
    _impl = new $interfaceName$ServerImpl();
    
    $createRPC(...); separator="\n"$
}
$interfaceName$ServerH::~$interfaceName$ServerH()
{
    delete _impl;    
}

$funImpls; separator="\n"$

$interfaceName$Server::$interfaceName$Server(eProsima::DDSRPC::ServerStrategy *strategy,
    int domainId) :
    $interfaceName$ServerH(strategy, new eProsima::DDSRPC::UDPTransport(), domainId)
{
}
$interfaceName$Server::~$interfaceName$Server()
{   
}

$interfaceName$WANServer::$interfaceName$WANServer(eProsima::DDSRPC::ServerStrategy *strategy,
    const char *public_address, const char *server_bind_port,
    int domainId) :
    $interfaceName$ServerH(strategy, new eProsima::DDSRPC::TCPTransport(public_address, server_bind_port), domainId)
{
}
$interfaceName$WANServer::~$interfaceName$WANServer()
{   
}
>>

/**
 * definitionImpl: External Template
 * Produces the interface implementation file.
 * Params:
 *   interfaceName: Name of the interface whose methods this proxy invokes.
 *   funNames     : list of the interface function names. 
 *   funImpls     : list of emptyFunctionImpl template outputs.
 *
 * Uses:
 */ 
definitionImpl(interfaceName, funNames, funImpls) ::= <<
/** 
 * Generated by DDSRPC                                              *
 * Empty interface implementation to be filled with your own code.  *
 */
 
#include "$interfaceName$ServerImpl.h"

$interfaceName$ServerImpl::$interfaceName$ServerImpl()
{
}
$interfaceName$ServerImpl::~$interfaceName$ServerImpl()
{
}

$funImpls; separator="\n"$
>>

/**
 * functionCall: External Template
 * Do nothing, just required to let the same code generating Proxy and Server.
 * Params:
 *   type:         function return type.
 *   name:         function name. 
 *   inputParams:  list of input params objects.
 *   inoutParams:  list of inout params objects.
 *   outputParams: list of output params objects.
 *
 * Uses:
 */ 
functionCall(type,name,inputParams,inoutParams,outputParams) ::= <<
>>

/**
 * main: External Template
 * Generates an example server program
 * Params:
 *   interfaceName: Name of the interface this server provides.
 *   invocations  : Not used. Just to have a common signature with functionHeader template. 
 *
 */ 
main(interfaceName, invocations) ::= <<
/** 
 * Generated by DDSRPC   *
 * Simplest server main  *
 */

#include "$interfaceName$Server.h"
#include "strategies/ThreadPoolStrategy.h"

int main(int argc, char **argv)
{
    int returnedValue = 0;
    int domainId = 0;
    unsigned int threadPoolSize = 5;
    eProsima::DDSRPC::ThreadPoolStrategy *pool = new eProsima::DDSRPC::ThreadPoolStrategy(threadPoolSize);
    $interfaceName$Server *server = new $interfaceName$Server(pool, domainId);
    server->executeServer();

    delete server;
    delete pool;
    
    return 0;
}

>>

/************************************************************************
 *                                                                      *
 *   Internal Templates: For internal use only.                         *
 *                                                                      *
 ************************************************************************
 */

/**
 * returnType: Internal Template
 * Declares a variable of function Return Type if not void.
 * If it is an user defined type also initializes it;
 * Params:
 *   type     : Variable type.
 *
 * Uses:
 *   voidInitMap - local
 *   typeInitMap - local
 */ 
returnType(type) ::= <<
$if(voidInitMap.(type))$
$elseif(typeInitMap.(type))$
$typeInitMap.(type)$ _ret_value_;
return _ret_value_;
$else$
$type$* _ret_value_ = new $type$();
return _ret_value_;
$endif$  
>>

/**
 * lastParam: Internal Template
 * Determines if the return value of the function should be included
 * in a call to ReplyUtils createTypeData method.
 * Params:
 *   params   : List of previous arguments in the function call. Nullable.
 *   type     :         function return type.
 *
 * Uses:
 *   voidInitMap - inherited(cplusplus)
 *   typeInitMap - inherited(cplusplus) 
 */ 
lastParam(params, type) ::= <<
$if(params)$
$if(!voidInitMap.(type))$, $endif$
$endif$
$if(!voidInitMap.(type))$
$if(!typeInitMap.(type))$*$endif$returnedValue$endif$
$endif$
>>


/**
 * exFunctionHeader: External Template
 * Produces a function header to be used in declaration & implementation 
 * Params:
 *   type         : function return type.
 *   class        : Class name. Must be null for declaration and not null for implementation
 *   inputParams  : not used. Just to have a common signature with functionHeader template.
 *   inoutParams  : not used. Just to have a common signature with functionHeader template.
 *   outputParams : not used. Just to have a common signature with functionHeader template.
 *
 * Uses:
 */ 
exFunctionHeader(type,class,name,inputParams,inoutParams,outputParams) ::= <<
$if(!class)$static $endif$void $class$$if(class)$ServerH::$endif$$name$(eProsima::DDSRPC::Server *server, void *requestData, eProsima::DDSRPC::ServerRPC *service)
>>

/**
 * extractTypeDataParams: Internal Template
 * Produces the params for calling Utils extractTypeData method 
 * Params:
 *   type         : function return type.
 *   inputParams  : list of input params objects.
 *   inoutParams  : list of inout params objects.
 *   outputParams : list of output params objects.
 *
 * Uses:
 *  nextParam - inherited(cplusplus)
 */ 
extractTypeDataParams(type, inputParams, inoutParams, outputParams) ::= <<
$[nextParam(params=inputParams),nextParam(previous=inputParams, params=inoutParams)]$
>>

/**
 * createRPC: Internal Template
 * Produces a list of Server inherited createRPC  method calls.
 * required to initialize this server object.
 * Params:
 *   funNames     : list of the interface function names. 
 *
 * Uses:
 */
createRPC(interfaceName, funNames) ::= <<
$funNames:{this->setRPC(new $it.name$ServerRPC("$it.name$", this,
            $it.name$RequestUtils::registerType(getParticipant()),
            $if(!it.isOneway)$
            $it.name$ReplyUtils::registerType(getParticipant()),
            $endif$
            &$interfaceName$ServerH::$it.name$, getParticipant()));
}$
>>

