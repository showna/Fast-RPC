/* $Id$   *
 * (c) Copyright, eProsima, 2009.                                          *
 * All rights reserved.                                                    *    
 *                                                                         *
 * No duplications, whole or partial, manual or electronic, may be made    *
 * without express written permission.  Any such copies, or                *
 * revisions thereof, must display this notice unaltered.                  *
 * This code contains trade secrets of                                     *
 * eProsima (Proyectos y Sistemas de Mantenimiento S.L.)                   *
 *                                                                         *
 * modification history                                                    *
 * --------------------                                                    *
 * 1.0,29sep09,RodM Created                                                *
 * =====================================================================   *
 */

group Proxy;

/************************************************************************
 *                                                                      *
 *   External Templates: Templates required to generate the Proxy       *
 *                                                                      *
 ************************************************************************
 */

/**
 * header: External Template
 * Produces the Proxy header file.
 * Params:
 *   interfaceName: Name of the interface whose methods this proxy invokes.
 *   funNames     : list of the interface function names. 
 *   funDecls     : list of functionHeader(cplusplus) template outputs.
 *
 * Uses:
 *  include - inherited(cplusplus)
 */ 
header(interfaceName, funNames, funDecls, funDeclsAsync, classDeclsAsync) ::= <<
#ifndef _$interfaceName;format="toUpper"$_PROXY_H_
#define _$interfaceName;format="toUpper"$_PROXY_H_

$doNotEditC()$

#include "client/Client.h"
#include "$interfaceName$RequestReplyUtils.h"
#include "$interfaceName$ClientRPCSupport.h"

$classDeclsAsync; separator=";\n"$$if(classDeclsAsync)$;$endif$

/**
 * \brief This class implements a specific client's proxy for the defined interface by user.
 */
class $interfaceName$ProxyH : public eProsima::DDSRPC::Client
{
    public:

        /**
         * \brief Default constructor. The client's proxy has to know what network transport
         *        it should use.
         *
         * \param transport The network transport that client's proxy has to use. Cannot be NULL.
         * \param domainId The DDS domain that DDS will use to work. Default value: 0
         * \param timeout Timeout used in each call to remotely procedures.
         *        If the call exceeds the time, the call return a eProsima::DDSRPC::SERVER_TIMEOUT.
         */
        $interfaceName$ProxyH(eProsima::DDSRPC::Transport *transport, int domainId = 0, long timeout = 10000);

        /// \brief The default destructor.
        virtual ~$interfaceName$ProxyH();
        
        $funDecls; separator=";\n"$;
        
        $funDeclsAsync; separator=";\n"$$if(funDeclsAsync)$;$endif$
        
    private:
        $funNames:{eProsima::DDSRPC::ClientRPC *$it$_Service;};separator="\n"$ 
};

/**
 * \brief This class implements a specific client's proxy for the defined interface by user.
 *        This client's proxy uses the UDPv4 transport.
 */
class $interfaceName$Proxy : public $interfaceName$ProxyH
{
    public:
    
        /**
         * \brief Default constructor.
         *
         * \param domainId The DDS domain that DDS will use to work. Default value: 0
         * \param timeout Timeout used in each call to remotely procedures.
         *        If the call exceeds the time, the call return a eProsima::DDSRPC::SERVER_TIMEOUT.
         */
        $interfaceName$Proxy(int domainId = 0, long timeout = 10000);
        
        virtual ~$interfaceName$Proxy();
};

/**
 * \brief This class implements a specific client's proxy for the defined interface by user.
 *        This client's proxy uses the TCPv4 transport.
 */
class $interfaceName$WANProxy : public $interfaceName$ProxyH
{
    public:
    
        /**
         * \brief Default constructor.
         *
         * \param to_connect Public address and port for the server. By example: "218.18.3.133:7600"
         * \param domainId The DDS domain that DDS will use to work. Default value: 0
         * \param timeout Timeout used in each call to remotely procedures.
         *        If the call exceeds the time, the call return a eProsima::DDSRPC::SERVER_TIMEOUT.
         */
        $interfaceName$WANProxy(const char *to_connect, int domainId = 0, long timeout = 10000);
        
        virtual ~$interfaceName$WANProxy();
};

#endif // _$interfaceName$_PROXY_H_
>>

classHeaderAsync(interfaceName,type,name,inoutParams,outputParams) ::= <<
class $interfaceName$_$name$
{
    public:
        virtual void $name$($if(inoutParams)$/*inout*/ $endif$$argDecl(inoutParams);separator=", "$ $if(inoutParams)$$if(outputParams)$, 
              $endif$$endif$$if(outputParams)$/*out*/ $endif$$argDecl(outputParams);separator=", "$)
        {
        }
   
        virtual void error(eProsima::DDSRPC::ReturnMessage message)
        {
        }
}
>>

functionHeaderAsync(interfaceName,type,class,name,inputParams,inoutParams) ::= << 
$functionReturnType(type)$ $class$$if(class)$::$endif$$name$_async($interfaceName$_$name$ &obj$if(inputParams)$, /*in*/ $endif$ $argDecl(inputParams);separator=", "$ $if(inoutParams)$, /*inout*/ 
              $endif$$argDecl(inoutParams);separator=", "$)
>>

/**
 * functionImpl: External Template
 * Produces the code required to call a function on the server.
 * Params:
 *   interfaceName: Name of the interface whose this function belongs to.
 *   type:         function return type.
 *   name:         function name. 
 *   inputParams:  list of input params objects.
 *   inoutParams:  list of inout params objects.
 *   outputParams: list of output params objects.
 *
 * Uses:
 *  voidInitMap           - inherited(cplusplus)
 *  varDecl               - inherited(cplusplus)
 *  nextParam             - inherited(cplusplus)
 *  extractTypeDataParams - inherited(cplusplus)
 */ 
functionImpl(interfaceName,type,name,inputParams,inoutParams,outputParams,isOneway) ::= <<
$functionHeader(class={$interfaceName$ProxyH},...)$ 
{
    $varDecl(type=type, name="returnedValue")$
    $name$Request *instance = NULL;
    $if(!isOneway)$$reqrepCreation(type=name, reqrep="Reply", name="retInstance", create="create")$$endif$

    instance = $name$RequestUtils::createTypeData($nextExtractParam(params=inputParams)$$nextExtractParam(previous=inputParams, params=inoutParams)$);
    returnedValue = $name$_Service->execute(instance, $if(!isOneway)$retInstance$else$NULL$endif$, getTimeout());
    switch (returnedValue)
    {
        case eProsima::DDSRPC::CLIENT_ERROR:
            printf("CLIENT ERROR\n");
            break;
        case eProsima::DDSRPC::RECEIVED_OTHER_REQUEST:
            printf("Y ESTE PAQUETE?\n");
            break;
        case eProsima::DDSRPC::SERVER_TIMEOUT:
            printf("TIMEOUT\n");
            break;
        case eProsima::DDSRPC::SERVER_ERROR:
            printf("SERVER ERROR\n");
            break;
        case eProsima::DDSRPC::WITHOUT_RESOURCES:
            printf("SERVER WITHOUT RESOURCES\n");
            break;
        case eProsima::DDSRPC::OPERATION_SUCCESSFUL:
            $if(!isOneway)$
            $name$ReplyUtils::extractTypeData(retInstance$if([inoutParams, outputParams])$, $extractTypeDataParams(inoutParams=inoutParams, outputParams=outputParams)$$endif$);
            //$name$ReplyTypeSupport::print_data(retInstance);          
            $endif$
            break;
    };
    
    $if(!isOneway)$$reqrepDestruction(type=name, reqrep="Reply", name="retInstance")$$endif$
    $reqrepDestruction(type=name, reqrep="Request", name="instance")$

    $if(!voidInitMap.(type))$
    return returnedValue;
    $endif$
}
>>

functionImplAsync(interfaceName,type,name,inputParams,inoutParams) ::= <<
$functionHeaderAsync(class={$interfaceName$ProxyH},...)$ 
{
    $varDecl(type=type, name="returnedValue")$
    $name$Request *instance = NULL;
    $interfaceName$_$name$Task *task = NULL;
    instance = $name$RequestUtils::createTypeData($nextExtractParam(params=inputParams)$$nextExtractParam(previous=inputParams, params=inoutParams)$);
    task = new $interfaceName$_$name$Task(obj, this);
    returnedValue = $name$_Service->executeAsync(instance, task, getTimeout());
    switch (returnedValue)
    {
        case eProsima::DDSRPC::CLIENT_ERROR:
            printf("CLIENT ERROR\n");
            break;
        case eProsima::DDSRPC::OPERATION_SUCCESSFUL:       
            break;
    };
    
    $reqrepDestruction(type=name, reqrep="Request", name="instance")$

    $if(!voidInitMap.(type))$
    return returnedValue;
    $endif$
}
>>

/**
 * definition: External Template
 * Produces the Proxy implementation file.
 * Params:
 *   interfaceName: Name of the interface whose methods this proxy invokes.
 *   funNames     : list of the interface function names. 
 *   funImpls     : list of functionImpl template outputs.
 *
 * Uses:
 *  createRPC - local
 */ 
definition(interfaceName, funNames, funImpls, funImplsAsync) ::= <<
$doNotEditC()$


#include "$interfaceName$Proxy.h"
#include "client/ClientRPC.h"
#include "transports/UDPTransport.h"
#include "transports/TCPTransport.h"
$ReqRepIncludes(interfaceName=interfaceName)$
#include "$interfaceName$AsyncSupport.h"


$interfaceName$ProxyH::$interfaceName$ProxyH(eProsima::DDSRPC::Transport *transport, int domainId, long timeout) :
    Client(transport, domainId, timeout)
{
    $createRPC(funNames); separator="\n"$
}

$interfaceName$ProxyH::~$interfaceName$ProxyH()
{
    $funNames:{delete $it.name$_Service;}; separator="\n"$
}

$funImpls; separator="\n"$

$funImplsAsync; separator="\n"$

$interfaceName$Proxy::$interfaceName$Proxy(int domainId, long timeout) :
    $interfaceName$ProxyH(new eProsima::DDSRPC::UDPTransport(), domainId, timeout)
{
}

$interfaceName$Proxy::~$interfaceName$Proxy()
{
}

$interfaceName$WANProxy::$interfaceName$WANProxy(const char *to_connect, int domainId, long timeout) :
    $interfaceName$ProxyH(new eProsima::DDSRPC::TCPTransport(to_connect), domainId, timeout)
{
}

$interfaceName$WANProxy::~$interfaceName$WANProxy()
{
}
>>

/**
 * functionCall: External Template
 * Produces the code to invoke a function on the proxy object.
 * Declares the required local variables (uninitialized!!!) and use them as params. 
 * Params:
 *   type:         function return type.
 *   name:         function name. 
 *   inputParams:  list of input params objects.
 *   inoutParams:  list of inout params objects.
 *   outputParams: list of output params objects.
 *
 * Uses:
 *  voidInitMap   - inherited(cplusplus)
 *  varDecl       - inherited(cplusplus)
 */ 
functionCall(type,name,string,inputParams,inoutParams,outputParams) ::= <<
    $inputParams:{$varDecl(type = it.type, name = it.name, create="yes", string = it.string)$}; separator="\n"$   
    $inoutParams:{$varDecl(type = it.type, name = it.name, create="yes", string = it.string)$}; separator="\n"$   
    $outputParams:{$varDecl(type = it.type, name = it.name, create="yes", string = it.string)$}; separator="\n"$   
    $varDecl(type=type, name=[name,"RetValue"])$    

    $if(!voidInitMap.(type))$
    $name$RetValue = 
    $endif$proxy->$name$($nextParam(params=inputParams)$$nextParam(previous=inputParams, params=inoutParams)$$nextParam(previous=[inputParams,inoutParams], params=outputParams)$);
    
    $inputParams:{$varDel(type = it.type, name = it.name, string = it.string)$}; separator="\n"$
    $inoutParams:{$varDel(type = it.type, name = it.name, string = it.string)$}; separator="\n"$
    $outputParams:{$varDel(type = it.type, name = it.name, string = it.string)$}; separator="\n"$
>>

/**
 * main: External Template
 * Generates an example client program
 * Params:
 *   interfaceName: Name of the interface whose methods this client invokes.
 *   invocations:   List of functionCall template outputs. 
 *
 */ 
main(interfaceName, invocations) ::= <<
/** 
 * Generated by DDSRPC                                                   *
 * Example client. Method params should be initialized before execution  *
 */

#include "$interfaceName$Proxy.h"
$ReqRepIncludes(interfaceName=interfaceName)$

int main(int argc, char **argv)
{
    int domainId = 0;
    unsigned int timeoutInMilliseconds = 10000;
    $interfaceName$Proxy *proxy = new $interfaceName$Proxy(domainId, timeoutInMilliseconds);
    
$invocations; separator="\n"$

   delete(proxy);
   
   return 0;
}
>>

/************************************************************************
 *                                                                      *
 *   Internal Templates: For internal use only.                         *
 *                                                                      *
 ************************************************************************
 */


/**
 * createRPC: Internal Template
 * Produces a list of Client inherited createRPC  method calls.
 * required to initialize this proxy object.
 * Params:
 *   funNames     : list of the interface function names. 
 *
 * Uses:
 */ 
createRPC(funNames) ::= <<
$funNames:{this->$it.name$_Service = new $it.name$ClientRPC("$it.name$",
                              $it.name$RequestUtils::registerType(getParticipant()),
                              $if(!it.isOneway)$
                              $it.name$ReplyUtils::registerType(getParticipant()),
                              $endif$
                              this);
}$
>>


/**
 * lastParam: Internal Template
 * Determines if the return value of the function should be included
 * in a call to RequestUtils extractTypeData method.
 * Params:
 *   params   : List of previous arguments in the function call. Nullable.
 *   type     :         function return type.
 *
 * Uses:
 *   voidInitMap - inherited(cplusplus)
 *   typeInitMap - inherited(cplusplus) 
 */ 
lastParam(params, type) ::= <<
$if(params)$
$if(!voidInitMap.(type))$, $endif$
$endif$
$if(!voidInitMap.(type))$
$if(!typeInitMap.(type))$*$endif$returnedValue$endif$
$endif$
>>

/**
 * extractTypeDataParams: Internal Template
 * Produces the params for calling RequestUtils extractTypeData method 
 * Params:
 *   inoutParams  : list of inout params objects.
 *   outputParams : list of output params objects.
 *
 * Uses:
 *  nextExtractParam - local
 */ 
extractTypeDataParams(inoutParams, outputParams) ::= <<
$[nextExtractParam(params=inoutParams),nextExtractParam(previous=inoutParams, params=outputParams)]$
>>

/**
 * varExtractUse: Internal Template
 * Uses the variable as a parameter to a funcion call 
 * checking if ti is a pointer or not. 
 * Params:
 *   type     : Variable type.
 *   name     : Variable name. 
 *
 * Uses:
 */ 
 varExtractUse(type, name) ::= <<
$if(typeInitMap.(type))$$name$
$else$
$name$
$endif$    
>>


/**
 * nextExtractParam: Internal Template
 * Adds arguments to a function call preceeding them by a comma
 * if there are previous arguments. 
 * Params:
 *   previous   : List of previous arguments in the function call. Nullable.
 *   params     : List of next arguments in the function call. Nullable.
 *
 * Uses:
 */ 
 nextExtractParam(previous, params) ::= <<
$if(previous)$
$if(params)$,
$endif$
$endif$
$params:{$varExtractUse(type = it.type, name = it.name)$};separator=", "$
>>
