/** 
 * Generated by DDSRPC                                                   *
 * Example client. Method params should be initialized before execution  *
 */

#include "MultithreadTestProxy.h"
#include "MultithreadTestRequestReplyPlugin.h"

#include "boost/config/user.hpp"
#include "boost/thread.hpp"

static struct RTIOsapiThreadFactory *factory = NULL;
static boost::thread thread1, thread2, thread3, thread4;
static MultithreadTestProxy *proxy = NULL;
static int run = 0;

void* executeThread(int threadNum)
{
    const char* const METHOD_NAME = "executeThread";
    char filename[50], fileLine[255];
    FILE *file = NULL;
    int count = 0;

    _snprintf(filename, 50, "Thread%d.txt", threadNum);
    file = fopen(filename, "w");
        
    if(file != NULL)
    {
        // Wait until start.
        while(!run)
        {
			boost::this_thread::sleep(boost::posix_time::seconds(1));
        }

        for(; count < 200; ++count)
        {
            Dato *dato1 = DatoPluginSupport_create_data();
            Dato *dato2 = DatoPluginSupport_create_data();    
            DDS_Long  test_ret;       
			eProsima::DDSRPC::ReturnMessage  testRetValue;

            dato1->count = count;

            testRetValue = proxy->test(dato1    ,dato2    , test_ret    );

			if(testRetValue == eProsima::DDSRPC::OPERATION_SUCCESSFUL)
            {
                _snprintf(fileLine, 255, "Received (%d)\n", count);
                fwrite(fileLine, strlen(fileLine), 1, file);
            }
            else
            {
                _snprintf(fileLine, 255, "Error in operation (%d)\n", count);
                fwrite(fileLine, strlen(fileLine), 1, file);
            }
                
            DatoPluginSupport_destroy_data(dato1);    
            DatoPluginSupport_destroy_data(dato2);    
        }

        fclose(file);
    }
    else
    {
        printf("ERROR<%s>: Cannot open file to log\n", METHOD_NAME);
    }

    return NULL;
}

int checkFiles()
{
	char filename[50];
	FILE *file = NULL;
	int returnedValue = 0, number = 0;

	for(int i = 1; i <= 4; ++i)
	{
		_snprintf(filename, 50, "Thread%d.txt", i);
		file = fopen(filename, "r");

		if(file != NULL)
		{
			for(int count = 0; count < 200; ++count)
			{
				fscanf(file, "Received (%d)\n", &number);

				if(number != count)
					returnedValue = -1;
			}

			fclose(file);
		}
		else
		{
			returnedValue = -1;
		}
	}

	return returnedValue;
}

int createThreads()
{
    const char* const METHOD_NAME = "createThreads";
    int returnedValue = -1;

	thread1 = boost::thread(executeThread, 1);
	thread2 = boost::thread(executeThread, 2);
	thread3 = boost::thread(executeThread, 3);
	thread4 = boost::thread(executeThread, 4);
	returnedValue = 0;

    return returnedValue;
}

int main()
{
    const char* const METHOD_NAME = "main";

    proxy = new MultithreadTestProxy(0, 4000);

    if(proxy != NULL)
    {
        // Create threads
        if(createThreads() == 0)
        {
            run = 1;
        }

		thread1.join();
		thread2.join();
		thread3.join();
		thread4.join();
		run = 0;

		if(checkFiles() != 0)
		{
			printf("TEST FAILED\n");
			_exit(-1);
		}
    }
    else
    {
        printf("ERROR<%s>: Cannot create proxy\n", METHOD_NAME);
    }

    printf("TEST SUCCESFULLY\n");
    
    delete(proxy);

	_exit(0);
}
