/** 
 * Generated by DDSCS: Do not edit.  Version 1.0 *
 */


#include "MultithreadTestProxy.h"
#include "client/ClientRPC.h"
#include "transports/UDPTransport.h"
#include "transports/TCPTransport.h"
#include "MultithreadTestRequestReplyPlugin.h"
#include "MultithreadTestAsyncSupport.h"


MultithreadTestProxyH::MultithreadTestProxyH(eProsima::DDSRPC::Transport *transport, int domainId, long timeout) :
    Client(transport, domainId, timeout)
{
    this->test_Service = new testClientRPC("test",
                                  testRequestUtils::registerType(getParticipant()),
                                  testReplyUtils::registerType(getParticipant()),
                                  this);

}

MultithreadTestProxyH::~MultithreadTestProxyH()
{
    delete test_Service;
}

 
eProsima::DDSRPC::ReturnMessage MultithreadTestProxyH::test(/*in*/ const Dato* dato1, /*out*/ Dato* &dato2, /*out*/ DDS_Long &test_ret) 
{
    eProsima::DDSRPC::ReturnMessage  returnedValue = eProsima::DDSRPC::OPERATION_SUCCESSFUL;    
    testRequest *instance = NULL;
    testReply* retInstance = testReplyTypeSupport::create_data();

    instance = testRequestUtils::createTypeData(dato1  );
    returnedValue = test_Service->execute(instance, retInstance, getTimeout());
    switch (returnedValue)
    {
        case eProsima::DDSRPC::CLIENT_ERROR:
            printf("CLIENT ERROR\n");
            break;
        case eProsima::DDSRPC::RECEIVED_OTHER_REQUEST:
            printf("Y ESTE PAQUETE?\n");
            break;
        case eProsima::DDSRPC::SERVER_TIMEOUT:
            printf("TIMEOUT\n");
            break;
        case eProsima::DDSRPC::SERVER_ERROR:
            printf("SERVER ERROR\n");
            break;
        case eProsima::DDSRPC::WITHOUT_RESOURCES:
            printf("SERVER WITHOUT RESOURCES\n");
            break;
        case eProsima::DDSRPC::OPERATION_SUCCESSFUL:
            testReplyUtils::extractTypeData(retInstance, dato2  , test_ret  );
            //testReplyTypeSupport::print_data(retInstance);          
            break;
    };
    
    testReplyTypeSupport::delete_data(retInstance);
    testRequestTypeSupport::delete_data(instance);

    return returnedValue;
}

 
eProsima::DDSRPC::ReturnMessage MultithreadTestProxyH::test_async(MultithreadTest_test &obj, /*in*/ const Dato* dato1) 
{
    eProsima::DDSRPC::ReturnMessage  returnedValue = eProsima::DDSRPC::OPERATION_SUCCESSFUL;    
    testRequest *instance = NULL;
    MultithreadTest_testTask *task = NULL;
    instance = testRequestUtils::createTypeData(dato1  );
    task = new MultithreadTest_testTask(obj, this);
    returnedValue = test_Service->executeAsync(instance, task, getTimeout());
    switch (returnedValue)
    {
        case eProsima::DDSRPC::CLIENT_ERROR:
            printf("CLIENT ERROR\n");
            break;
        case eProsima::DDSRPC::OPERATION_SUCCESSFUL:       
            break;
    };
    
    testRequestTypeSupport::delete_data(instance);

    return returnedValue;
}

MultithreadTestProxy::MultithreadTestProxy(int domainId, long timeout) :
    MultithreadTestProxyH(new eProsima::DDSRPC::UDPTransport(), domainId, timeout)
{
}

MultithreadTestProxy::~MultithreadTestProxy()
{
}

MultithreadTestWANProxy::MultithreadTestWANProxy(const char *to_connect, int domainId, long timeout) :
    MultithreadTestProxyH(new eProsima::DDSRPC::TCPTransport(to_connect), domainId, timeout)
{
}

MultithreadTestWANProxy::~MultithreadTestWANProxy()
{
}