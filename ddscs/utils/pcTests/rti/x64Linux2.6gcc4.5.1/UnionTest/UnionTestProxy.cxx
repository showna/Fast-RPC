/*************************************************************************
 * Copyright (c) 2012 eProsima. All rights reserved.
 *
 * This copy of RPCDDS is licensed to you under the terms described in the
 * RPCDDS_LICENSE file included in this distribution.
 *
 *************************************************************************
 * 
 * @file UnionTestProxy.cxx
 * This source file contains the definition of the proxy for interface UnionTest.
 *
 * This file was generated by the tool rpcddsgen.
 */

#include "UnionTestProxy.h"
#include "client/ClientRPC.h"
#include "transports/UDPTransport.h"
#include "transports/TCPTransport.h"
#include "UnionTestRequestReplyPlugin.h"
#include "UnionTestAsyncSupport.h"
#include "exceptions/Exceptions.h"

UnionTestProxy::UnionTestProxy(std::string remoteServiceName, int domainId, long timeout) :
    Client(remoteServiceName, NULL, domainId, timeout)
{
    createRPCs();
}

UnionTestProxy::UnionTestProxy(std::string remoteServiceName, eProsima::RPCDDS::Transport *transport, int domainId, long timeout) :
    Client(remoteServiceName, transport, domainId, timeout)
{
    createRPCs();
}

UnionTestProxy::~UnionTestProxy()
{
    delete getEmpleado_Service;
}

void UnionTestProxy::createRPCs()
{
    this->getEmpleado_Service = new UnionTest_getEmpleadoClientRPC("getEmpleado",
                                  UnionTest_getEmpleadoRequestUtils::registerType(getParticipant()),
                                  UnionTest_getEmpleadoReplyUtils::registerType(getParticipant()),
                                  this);

}

 
Empleado UnionTestProxy::getEmpleado(/*in*/ const Empleado& em1, /*inout*/ Empleado& em2, /*out*/ Empleado& em3) 
{
    eProsima::RPCDDS::ReturnMessage retcode = eProsima::RPCDDS::CLIENT_INTERNAL_ERROR;
    Empleado getEmpleado_ret;
    UnionTest_getEmpleadoRequest instance;
    UnionTest_getEmpleadoReply retInstance;

    UnionTest_getEmpleadoReply_initialize(&retInstance);
    UnionTest_getEmpleadoRequestUtils::setTypeData(instance, em1, em2);
    retcode = getEmpleado_Service->execute(&instance, &retInstance, getTimeout());
    
    if(retcode == eProsima::RPCDDS::OPERATION_SUCCESSFUL)
    {
        UnionTest_getEmpleadoReplyUtils::extractTypeData(retInstance, retcode, em2, em3, getEmpleado_ret);  
    }
    
    switch (retcode)
    {
        case eProsima::RPCDDS::CLIENT_INTERNAL_ERROR:
            throw eProsima::RPCDDS::ClientInternalException("Error in client side");
            break;
        case eProsima::RPCDDS::NO_SERVER:
            throw eProsima::RPCDDS::ServerNotFoundException("Cannot connect to the server");
            break;
        case eProsima::RPCDDS::SERVER_TIMEOUT:
            throw eProsima::RPCDDS::ServerTimeoutException("Timeout waiting the server's reply");
            break;
        case eProsima::RPCDDS::SERVER_INTERNAL_ERROR:
            throw eProsima::RPCDDS::ServerInternalException(retInstance.header.rpcddsRetMsg);
            break;
    };
    

    return getEmpleado_ret;
}

 
void UnionTestProxy::getEmpleado_async(UnionTest_getEmpleadoCallbackHandler &obj, /*in*/ const Empleado& em1, /*inout*/ const Empleado& em2) 
{
	eProsima::RPCDDS::ReturnMessage retcode = eProsima::RPCDDS::CLIENT_INTERNAL_ERROR;
    UnionTest_getEmpleadoRequest instance;
    UnionTest_getEmpleadoTask *task = NULL;
    UnionTest_getEmpleadoRequestUtils::setTypeData(instance, em1, em2);
    task = new UnionTest_getEmpleadoTask(obj, this);
    retcode = getEmpleado_Service->executeAsync(&instance, task, getTimeout());
    
    switch (retcode)
    {
        case eProsima::RPCDDS::CLIENT_INTERNAL_ERROR:
            throw eProsima::RPCDDS::ClientInternalException("Error in client side");
            break;
        case eProsima::RPCDDS::NO_SERVER:
             throw eProsima::RPCDDS::ServerNotFoundException("Cannot connect to the server");
             break;
    }
}