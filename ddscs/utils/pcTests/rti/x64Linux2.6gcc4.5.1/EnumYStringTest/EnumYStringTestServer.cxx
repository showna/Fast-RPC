/*************************************************************************
 * Copyright (c) 2012 eProsima. All rights reserved.
 *
 * This copy of RPCDDS is licensed to you under the terms described in the
 * RPCDDS_LICENSE file included in this distribution.
 *
 *************************************************************************
 * 
 * @file EnumYStringTestServer.cxx
 * This source file contains the definition of the server for interface EnumYStringTest.
 *
 * This file was generated by the tool rpcddsgen.
 */

#include "EnumYStringTestServer.h"
#include "transports/UDPTransport.h"
#include "transports/TCPTransport.h"
#include "exceptions/ServerInternalException.h"
#include "EnumYStringTestRequestReplyPlugin.h"

#include "EnumYStringTestServerRPCSupport.h"

EnumYStringTestServer::EnumYStringTestServer(std::string serviceName, eProsima::RPCDDS::ServerStrategy *strategy,
    int domainId) :
    Server(serviceName, strategy, NULL, domainId)
{
    _impl = new EnumYStringTestServerImpl();

    createRPCs();
}

EnumYStringTestServer::EnumYStringTestServer(std::string serviceName, eProsima::RPCDDS::ServerStrategy *strategy,
    eProsima::RPCDDS::Transport *transport, int domainId) :
    Server(serviceName, strategy, transport, domainId)
{
    _impl = new EnumYStringTestServerImpl();
    
    createRPCs();
}

EnumYStringTestServer::~EnumYStringTestServer()
{
    delete _impl;    
}

void EnumYStringTestServer::createRPCs()
{
    this->setRPC(new EnumYStringTest_getEnumServerRPC("getEnum", this,
                EnumYStringTest_getEnumRequestUtils::registerType(getParticipant()),
                EnumYStringTest_getEnumReplyUtils::registerType(getParticipant()),
                &EnumYStringTestServer::getEnum));
    this->setRPC(new EnumYStringTest_getStringServerRPC("getString", this,
                EnumYStringTest_getStringRequestUtils::registerType(getParticipant()),
                EnumYStringTest_getStringReplyUtils::registerType(getParticipant()),
                &EnumYStringTestServer::getString));
    this->setRPC(new EnumYStringTest_getStringBoundedServerRPC("getStringBounded", this,
                EnumYStringTest_getStringBoundedRequestUtils::registerType(getParticipant()),
                EnumYStringTest_getStringBoundedReplyUtils::registerType(getParticipant()),
                &EnumYStringTestServer::getStringBounded));

}

void EnumYStringTestServer::getEnum(eProsima::RPCDDS::Server *server, void *requestData, eProsima::RPCDDS::ServerRPC *service) 
{ 
    EnumYStringTestServer *srv = dynamic_cast<EnumYStringTestServer*>(server);
    Valores  v1 = VALOR1;
    Valores  v2 = VALOR1;
    Valores  v3 = VALOR1;
    Valores  getEnum_ret = VALOR1;   
    EnumYStringTest_getEnumReply replyData;
    

    EnumYStringTest_getEnumRequestUtils::extractTypeData(*(EnumYStringTest_getEnumRequest*)requestData, v1, v2);

    try
    {
        getEnum_ret = srv->_impl->getEnum(v1, v2, v3);

        EnumYStringTest_getEnumReplyUtils::setTypeData(replyData, v2, v3, getEnum_ret);
        replyData.header.rpcddsRetCode = eProsima::RPCDDS::OPERATION_SUCCESSFUL;
        replyData.header.rpcddsRetMsg = NULL;

        service->sendReply(requestData, &replyData);
    }
    catch(const eProsima::RPCDDS::ServerInternalException &ex)
    {
        memset(&replyData, 0, sizeof(replyData));
        replyData.header.rpcddsRetCode = eProsima::RPCDDS::SERVER_INTERNAL_ERROR;
        replyData.header.rpcddsRetMsg = (char*)ex.what();
        
        service->sendReply(requestData, &replyData);
    }
    
    EnumYStringTest_getEnumRequestTypeSupport::delete_data((EnumYStringTest_getEnumRequest*)requestData);
    

}
void EnumYStringTestServer::getString(eProsima::RPCDDS::Server *server, void *requestData, eProsima::RPCDDS::ServerRPC *service) 
{ 
    EnumYStringTestServer *srv = dynamic_cast<EnumYStringTestServer*>(server);
    char*  s1 = NULL;
    char*  s2 = NULL;
    char*  s3 = NULL;
    char*  getString_ret = NULL;   
    EnumYStringTest_getStringReply replyData;
    

    EnumYStringTest_getStringRequestUtils::extractTypeData(*(EnumYStringTest_getStringRequest*)requestData, s1, s2);

    try
    {
        getString_ret = srv->_impl->getString(s1, s2, s3);

        EnumYStringTest_getStringReplyUtils::setTypeData(replyData, s2, s3, getString_ret);
        replyData.header.rpcddsRetCode = eProsima::RPCDDS::OPERATION_SUCCESSFUL;
        replyData.header.rpcddsRetMsg = NULL;

        service->sendReply(requestData, &replyData);
    }
    catch(const eProsima::RPCDDS::ServerInternalException &ex)
    {
        memset(&replyData, 0, sizeof(replyData));
        replyData.header.rpcddsRetCode = eProsima::RPCDDS::SERVER_INTERNAL_ERROR;
        replyData.header.rpcddsRetMsg = (char*)ex.what();
        
        service->sendReply(requestData, &replyData);
    }
    
    EnumYStringTest_getStringRequestTypeSupport::delete_data((EnumYStringTest_getStringRequest*)requestData);
    
    if(getString_ret != NULL) free(getString_ret);
    if(s2 != NULL) free(s2);
    if(s3 != NULL) free(s3);
}
void EnumYStringTestServer::getStringBounded(eProsima::RPCDDS::Server *server, void *requestData, eProsima::RPCDDS::ServerRPC *service) 
{ 
    EnumYStringTestServer *srv = dynamic_cast<EnumYStringTestServer*>(server);
    char*  sb1 = NULL;
    char*  sb2 = NULL;
    char*  sb3 = NULL;
    char*  getStringBounded_ret = NULL;   
    EnumYStringTest_getStringBoundedReply replyData;
    

    EnumYStringTest_getStringBoundedRequestUtils::extractTypeData(*(EnumYStringTest_getStringBoundedRequest*)requestData, sb1, sb2);

    try
    {
        getStringBounded_ret = srv->_impl->getStringBounded(sb1, sb2, sb3);

        EnumYStringTest_getStringBoundedReplyUtils::setTypeData(replyData, sb2, sb3, getStringBounded_ret);
        replyData.header.rpcddsRetCode = eProsima::RPCDDS::OPERATION_SUCCESSFUL;
        replyData.header.rpcddsRetMsg = NULL;

        service->sendReply(requestData, &replyData);
    }
    catch(const eProsima::RPCDDS::ServerInternalException &ex)
    {
        memset(&replyData, 0, sizeof(replyData));
        replyData.header.rpcddsRetCode = eProsima::RPCDDS::SERVER_INTERNAL_ERROR;
        replyData.header.rpcddsRetMsg = (char*)ex.what();
        
        service->sendReply(requestData, &replyData);
    }
    
    EnumYStringTest_getStringBoundedRequestTypeSupport::delete_data((EnumYStringTest_getStringBoundedRequest*)requestData);
    
    if(getStringBounded_ret != NULL) free(getStringBounded_ret);
    if(sb2 != NULL) free(sb2);
    if(sb3 != NULL) free(sb3);
}