/** 
 * Generated by RPCDDS                                                   *
 * Example client. Method params should be initialized before execution  *
 */

#include "MultithreadTestProxy.h"
#include "MultithreadTestRequestReplyPlugin.h"
#include "exceptions/Exceptions.h"

#include "boost/config/user.hpp"
#include "boost/thread.hpp"

static struct RTIOsapiThreadFactory *factory = NULL;
static boost::thread thread1, thread2, thread3, thread4;
static MultithreadTestProxy *proxy = NULL;
static int run = 0;

void* executeThread(int threadNum)
{
    const char* const METHOD_NAME = "executeThread";
    char filename[50], fileLine[255];
    FILE *file = NULL;
    int count = 0;

#if defined(RTI_WIN32)
    _snprintf(filename, 50, "Thread%d.txt", threadNum);
#elif defined(RTI_LINUX)
    snprintf(filename, 50, "Thread%d.txt", threadNum);
#endif
    file = fopen(filename, "w");

    if(file != NULL)
    {
        // Wait until start.
        while(!run)
        {
            boost::this_thread::sleep(boost::posix_time::seconds(1));
        }

        for(; count < 200; ++count)
        {
            Dato dato1;
            Dato dato2;
            DDS_Long  test_ret = 0;       

            Dato_initialize(&dato1);
            Dato_initialize(&dato2);

            dato1.count = count;

            try
            {
                test_ret =  proxy->test(dato1 ,dato2);
#if defined(RTI_WIN32)
                _snprintf(fileLine, 255, "Received (%d)\n", count);
#elif defined(RTI_LINUX)
                snprintf(fileLine, 255, "Received (%d)\n", count);
#endif
                fwrite(fileLine, strlen(fileLine), 1, file);
            }
            catch(eProsima::RPCDDS::Exception &ex)
            {
#if defined(RTI_WIN32)
                _snprintf(fileLine, 255, "Error in operation (%d). %s\n", count, ex.what());
#elif defined(RTI_LINUX)
                snprintf(fileLine, 255, "Error in operation (%d). %s\n", count, ex.what());
#endif
                fwrite(fileLine, strlen(fileLine), 1, file);
            }

            Dato_finalize(&dato1);
            Dato_finalize(&dato2);
        }

        fclose(file);
    }
    else
    {
        printf("ERROR<%s>: Cannot open file to log\n", METHOD_NAME);
    }

    return NULL;
}

int checkFiles()
{
    char filename[50];
    FILE *file = NULL;
    int returnedValue = 0, number = 0;

    for(int i = 1; i <= 4; ++i)
    {
#if defined(RTI_WIN32)
        _snprintf(filename, 50, "Thread%d.txt", i);
#elif defined(RTI_LINUX)
        _snprintf(filename, 50, "Thread%d.txt", i);
#endif
        file = fopen(filename, "r");

        if(file != NULL)
        {
            for(int count = 0; count < 200; ++count)
            {
                fscanf(file, "Received (%d)\n", &number);

                if(number != count)
                    returnedValue = -1;
            }

            fclose(file);
        }
        else
        {
            returnedValue = -1;
        }
    }

    return returnedValue;
}

int createThreads()
{
    const char* const METHOD_NAME = "createThreads";
    int returnedValue = -1;

    thread1 = boost::thread(executeThread, 1);
    thread2 = boost::thread(executeThread, 2);
    thread3 = boost::thread(executeThread, 3);
    thread4 = boost::thread(executeThread, 4);
    returnedValue = 0;

    return returnedValue;
}

int main(int argc, char **argv)
{
    const char* const METHOD_NAME = "main";

    proxy = new MultithreadTestProxy("MultithreadTestService");

    if(proxy != NULL)
    {
        // Create threads
        if(createThreads() == 0)
        {
            run = 1;
        }

        thread1.join();
        thread2.join();
        thread3.join();
        thread4.join();
        run = 0;

        if(checkFiles() != 0)
        {
            printf("TEST FAILED\n");
            _exit(-1);
        }
    }
    else
    {
        printf("ERROR<%s>: Cannot create proxy\n", METHOD_NAME);
    }

    printf("TEST SUCCESFULLY\n");

    delete(proxy);

    _exit(0);
    return 0;
}
