/** 
 * Generated by DDSCS: Do not edit.  Version 1.0 *
 */


#include "SequenceTestProxy.h"
#include "client/ClientRPC.h"
#include "SequenceTestRequestReplyPlugin.h"


SequenceTestProxy::SequenceTestProxy(int domainId, unsigned int timeout
, const char *qosLibrary, const char *qosProfile) : Client(domainId, qosLibrary, qosProfile)
{
    m_timeout = timeout;
    this->getSLong_Service = new getSLongClientRPC("getSLong",
                                  getSLongRequestUtils::registerType(getParticipant()),
    "SequenceTest_Library",
    "SequenceTest_Profile",
                                  getSLongReplyUtils::registerType(getParticipant()),
    "SequenceTest_Library",
    "SequenceTest_Profile",
                                  getParticipant());
    this->getString_Service = new getStringClientRPC("getString",
                                  getStringRequestUtils::registerType(getParticipant()),
    "SequenceTest_Library",
    "SequenceTest_Profile",
                                  getStringReplyUtils::registerType(getParticipant()),
    "SequenceTest_Library",
    "SequenceTest_Profile",
                                  getParticipant());
    this->getStringBounded_Service = new getStringBoundedClientRPC("getStringBounded",
                                  getStringBoundedRequestUtils::registerType(getParticipant()),
    "SequenceTest_Library",
    "SequenceTest_Profile",
                                  getStringBoundedReplyUtils::registerType(getParticipant()),
    "SequenceTest_Library",
    "SequenceTest_Profile",
                                  getParticipant());

}

SequenceTestProxy::~SequenceTestProxy()
{
    delete getSLong_Service;
    delete getString_Service;
    delete getStringBounded_Service;
}

unsigned int SequenceTestProxy::getTimeout()
{
  return m_timeout;
}
 
 void SequenceTestProxy::setTimeout(unsigned int millis)
 {
    m_timeout = millis;
 }

 
eProsima::DDSRPC::ReturnMessage
 SequenceTestProxy::getSLong(largo* l1 ,largo* &l2,largo* &l3, largo* &getSLong_ret) 
{
    eProsima::DDSRPC::ReturnMessage  returnedValue ;    
    getSLongRequest *instance = NULL;
    getSLongReply *retInstance = getSLongReplyTypeSupport::create_data();
    instance = getSLongRequestUtils::createTypeData(l1    ,l2    );
    returnedValue = getSLong_Service->execute(instance, retInstance, m_timeout);
    switch (returnedValue)
    {
        case eProsima::DDSRPC::CLIENT_ERROR:
            printf("CLIENT ERROR\n");
            break;
        case eProsima::DDSRPC::RECEIVED_OTHER_REQUEST:
            printf("Y ESTE PAQUETE?\n");
            break;
        case eProsima::DDSRPC::SERVER_TIMEOUT:
            printf("TIMEOUT\n");
            break;
        case eProsima::DDSRPC::SERVER_ERROR:
            printf("SERVER ERROR\n");
            break;
        case eProsima::DDSRPC::WITHOUT_RESOURCES:
            printf("SERVER WITHOUT RESOURCES\n");
            break;
        case eProsima::DDSRPC::OPERATION_SUCCESSFUL:
            getSLongReplyUtils::extractTypeData(retInstance, l2    ,l3    , getSLong_ret    );
            //getSLongReplyTypeSupport::print_data(retInstance);          
            break;
    };
    
    getSLongReplyTypeSupport::delete_data(retInstance);
    getSLongRequestTypeSupport::delete_data(instance);

    return returnedValue;
}
 
eProsima::DDSRPC::ReturnMessage
 SequenceTestProxy::getString(cadena* s1 ,cadena* &s2,cadena* &s3, cadena* &getString_ret) 
{
    eProsima::DDSRPC::ReturnMessage  returnedValue ;    
    getStringRequest *instance = NULL;
    getStringReply *retInstance = getStringReplyTypeSupport::create_data();
    instance = getStringRequestUtils::createTypeData(s1    ,s2    );
    returnedValue = getString_Service->execute(instance, retInstance, m_timeout);
    switch (returnedValue)
    {
        case eProsima::DDSRPC::CLIENT_ERROR:
            printf("CLIENT ERROR\n");
            break;
        case eProsima::DDSRPC::RECEIVED_OTHER_REQUEST:
            printf("Y ESTE PAQUETE?\n");
            break;
        case eProsima::DDSRPC::SERVER_TIMEOUT:
            printf("TIMEOUT\n");
            break;
        case eProsima::DDSRPC::SERVER_ERROR:
            printf("SERVER ERROR\n");
            break;
        case eProsima::DDSRPC::WITHOUT_RESOURCES:
            printf("SERVER WITHOUT RESOURCES\n");
            break;
        case eProsima::DDSRPC::OPERATION_SUCCESSFUL:
            getStringReplyUtils::extractTypeData(retInstance, s2    ,s3    , getString_ret    );
            //getStringReplyTypeSupport::print_data(retInstance);          
            break;
    };
    
    getStringReplyTypeSupport::delete_data(retInstance);
    getStringRequestTypeSupport::delete_data(instance);

    return returnedValue;
}
 
eProsima::DDSRPC::ReturnMessage
 SequenceTestProxy::getStringBounded(dattos* sb1 ,dattos* &sb2,dattos* &sb3, dattos* &getStringBounded_ret) 
{
    eProsima::DDSRPC::ReturnMessage  returnedValue ;    
    getStringBoundedRequest *instance = NULL;
    getStringBoundedReply *retInstance = getStringBoundedReplyTypeSupport::create_data();
    instance = getStringBoundedRequestUtils::createTypeData(sb1    ,sb2    );
    returnedValue = getStringBounded_Service->execute(instance, retInstance, m_timeout);
    switch (returnedValue)
    {
        case eProsima::DDSRPC::CLIENT_ERROR:
            printf("CLIENT ERROR\n");
            break;
        case eProsima::DDSRPC::RECEIVED_OTHER_REQUEST:
            printf("Y ESTE PAQUETE?\n");
            break;
        case eProsima::DDSRPC::SERVER_TIMEOUT:
            printf("TIMEOUT\n");
            break;
        case eProsima::DDSRPC::SERVER_ERROR:
            printf("SERVER ERROR\n");
            break;
        case eProsima::DDSRPC::WITHOUT_RESOURCES:
            printf("SERVER WITHOUT RESOURCES\n");
            break;
        case eProsima::DDSRPC::OPERATION_SUCCESSFUL:
            getStringBoundedReplyUtils::extractTypeData(retInstance, sb2    ,sb3    , getStringBounded_ret    );
            //getStringBoundedReplyTypeSupport::print_data(retInstance);          
            break;
    };
    
    getStringBoundedReplyTypeSupport::delete_data(retInstance);
    getStringBoundedRequestTypeSupport::delete_data(instance);

    return returnedValue;
}