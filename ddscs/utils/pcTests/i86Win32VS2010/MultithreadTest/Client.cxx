/** 
 * Generated by DDSCS                                                    *
 * Example client. Method params should be initialized before execution  *
 */

#include "MultithreadTestProxy.h"
#include "MultithreadTestRequestReplyPlugin.h"

static struct RTIOsapiThreadFactory *factory = NULL;
static struct RTIOsapiThread *thread1 = NULL, *thread2 = NULL,
*thread3 = NULL, *thread4 = NULL;
static int exitThread[4] = {0, 0, 0, 0}, threadNumber[4] = {1, 2, 3, 4};
static MultithreadTestProxy *proxy = NULL;
static int run = 0;

void* executeThread(void *arg)
{
    const char* const METHOD_NAME = "executeThread";
    int threadNum = *((int*)arg);
    char filename[50], fileLine[255];
    FILE *file = NULL;
    RTINtpTime sleepTime = {1, 0};
    int count = 0;

    if(threadNum != NULL)
    {
        _snprintf(filename, 50, "Thread%d.txt", threadNum);
        file = fopen(filename, "w");
        
        if(file != NULL)
        {
            // Wait until start.
            while(!run)
            {
                RTIOsapiThread_sleep(&sleepTime);
            }

            for(; count < 200; ++count)
            {
                Dato *dato1 = DatoPluginSupport_create_data();
                Dato *dato2 = DatoPluginSupport_create_data();    
                DDS_Long  test_ret;       
                DDSCSMessages  testRetValue;

                dato1->count = count;
                _snprintf(dato1->message, 255, "Esto es una prueba %d\n", count);

                testRetValue = proxy->test(*dato1    ,*dato2    , test_ret    );

                if(testRetValue == OPERATION_SUCCESSFUL)
                {
                    _snprintf(fileLine, 255, "Received (%d)\n", count);
                    fwrite(fileLine, strlen(fileLine), 1, file);
                }
                else
                {
                    _snprintf(fileLine, 255, "Error in operation (%d)\n", count);
                    fwrite(fileLine, strlen(fileLine), 1, file);
                }
                
                DatoPluginSupport_destroy_data(dato1);    
                DatoPluginSupport_destroy_data(dato2);    
            }

            fclose(file);

            exitThread[threadNum - 1] = 1;
        }
        else
        {
            printf("ERROR<%s>: Cannot open file to log\n", METHOD_NAME);
        }
    }
    else
    {
        printf("ERROR<%s>: Bad parameter\n", METHOD_NAME);
    }

    return NULL;
}

int createThreads()
{
    const char* const METHOD_NAME = "createThreads";
    int returnedValue = -1;

    if(proxy != NULL)
    {
        factory = RTIOsapiThreadFactory_newDefault();

        if(factory != NULL)
        {
            thread1 = RTIOsapiThreadFactory_createThread(factory, "Thread1", RTI_OSAPI_THREAD_PRIORITY_NORMAL,
                RTI_OSAPI_THREAD_OPTION_DEFAULT, 4096, NULL, (void*(*)(void*))executeThread, &threadNumber[0]);

            if(thread1 != NULL)
            {
                thread2 = RTIOsapiThreadFactory_createThread(factory, "Thread2", RTI_OSAPI_THREAD_PRIORITY_NORMAL,
                RTI_OSAPI_THREAD_OPTION_DEFAULT, 4096, NULL, (void*(*)(void*))executeThread, &threadNumber[1]);

                if(thread2 != NULL)
                {
                    thread3 = RTIOsapiThreadFactory_createThread(factory, "Thread3", RTI_OSAPI_THREAD_PRIORITY_NORMAL,
                    RTI_OSAPI_THREAD_OPTION_DEFAULT, 4096, NULL, (void*(*)(void*))executeThread, &threadNumber[2]);

                    if(thread3 != NULL)
                    {
                        thread4 = RTIOsapiThreadFactory_createThread(factory, "Thread4", RTI_OSAPI_THREAD_PRIORITY_NORMAL,
                        RTI_OSAPI_THREAD_OPTION_DEFAULT, 4096, NULL, (void*(*)(void*))executeThread, &threadNumber[3]);

                        if(thread4 != NULL)
                        {
                            returnedValue = 0;
                        }
                        else
                        {
                            printf("ERROR<%s>: Cannot create thread4\n", METHOD_NAME);
                        }
                    }
                    else
                    {
                        printf("ERROR<%s>: Cannot create thread3\n", METHOD_NAME);
                    }
                }
                else
                {
                    printf("ERROR<%s>: Cannot create thread2\n", METHOD_NAME);
                }
            }
            else
            {
                printf("ERROR<%s>: Cannot create thread1\n", METHOD_NAME);
            }
        }
        else
        {
            printf("ERROR<%s>: Cannot create thread factory\n", METHOD_NAME);
        }
    }
    else
    {
        printf("ERROR<%s>: Bad parameter\n", METHOD_NAME);
    }

    return returnedValue;
}

int main()
{
    const char* const METHOD_NAME = "main";
    DDS_Duration_t period = {5,0}, sleepPeriod = {1, 0};

    proxy = new MultithreadTestProxy(0, 4000);

    if(proxy != NULL)
    {
        // Create threads
        if(createThreads() == 0)
        {
            run = 1;
        }

        while(exitThread[0] == 0 || exitThread[1] == 0 ||
            exitThread[2] == 0 || exitThread[3] == 0)
        {
            NDDSUtility::sleep(sleepPeriod);
        }
    }
    else
    {
        printf("ERROR<%s>: Cannot create proxy\n", METHOD_NAME);
    }

    printf("Existing...\n");
    
    delete(proxy);
    NDDSUtility::sleep(period);
}