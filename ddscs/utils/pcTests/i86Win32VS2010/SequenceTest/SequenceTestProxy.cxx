/** 
 * Generated by DDSCS: Do not edit.  Version 1.0 *
 */


#include "SequenceTestProxy.h"
#include "client/ClientRemoteService.h"
#include "SequenceTestRequestReplyPlugin.h"


SequenceTestProxy::SequenceTestProxy(int domainId, unsigned int timeout
, const char *qosLibrary, const char *qosProfile) : DDSCSClient(domainId, qosLibrary, qosProfile)
{
    m_timeout = timeout;
    this->getSLong_Service = new getSLongClientRemoteService("getSLong",
                                  getSLongRequestUtils::registerType(getParticipant()),
    "SequenceTest_Library",
    "SequenceTest_Profile",
                                  getSLongReplyUtils::registerType(getParticipant()),
    "SequenceTest_Library",
    "SequenceTest_Profile",
                                  getParticipant());
    this->getString_Service = new getStringClientRemoteService("getString",
                                  getStringRequestUtils::registerType(getParticipant()),
    "SequenceTest_Library",
    "SequenceTest_Profile",
                                  getStringReplyUtils::registerType(getParticipant()),
    "SequenceTest_Library",
    "SequenceTest_Profile",
                                  getParticipant());
    this->getStringBounded_Service = new getStringBoundedClientRemoteService("getStringBounded",
                                  getStringBoundedRequestUtils::registerType(getParticipant()),
    "SequenceTest_Library",
    "SequenceTest_Profile",
                                  getStringBoundedReplyUtils::registerType(getParticipant()),
    "SequenceTest_Library",
    "SequenceTest_Profile",
                                  getParticipant());

}

SequenceTestProxy::~SequenceTestProxy()
{
    delete getSLong_Service;
    delete getString_Service;
    delete getStringBounded_Service;
}

unsigned int SequenceTestProxy::getTimeout()
{
  return m_timeout;
}
 
 void SequenceTestProxy::setTimeout(unsigned int millis)
 {
    m_timeout = millis;
 }

 
DDSCSMessages
 SequenceTestProxy::getSLong(largo & l1 ,largo  &l2,largo  &l3, largo  &getSLong_ret) 
{
    DDSCSMessages  returnedValue ;    
    getSLongRequest *instance = NULL;
    getSLongReply *retInstance = getSLongReplyTypeSupport::create_data();
    instance = getSLongRequestUtils::createTypeData(l1    ,l2    );
    returnedValue = getSLong_Service->execute(instance, retInstance, m_timeout);
    switch (returnedValue)
    {
        case CLIENT_ERROR:
            printf("CLIENT ERROR\n");
            break;
        case RECEIVED_OTHER_REQUEST:
            printf("Y ESTE PAQUETE?\n");
            break;
        case SERVER_TIMEOUT:
            printf("TIMEOUT\n");
            break;
        case SERVER_ERROR:
            printf("SERVER ERROR\n");
            break;
        case WITHOUT_RESOURCES:
            printf("SERVER WITHOUT RESOURCES\n");
            break;
        case OPERATION_SUCCESSFUL:
            getSLongReplyUtils::extractTypeData(retInstance, l2    ,l3    , getSLong_ret    );
            //getSLongReplyTypeSupport::print_data(retInstance);          
            break;
    };
    
    getSLongReplyTypeSupport::delete_data(retInstance);
    getSLongRequestTypeSupport::delete_data(instance);

    return returnedValue;
}
 
DDSCSMessages
 SequenceTestProxy::getString(cadena & s1 ,cadena  &s2,cadena  &s3, cadena  &getString_ret) 
{
    DDSCSMessages  returnedValue ;    
    getStringRequest *instance = NULL;
    getStringReply *retInstance = getStringReplyTypeSupport::create_data();
    instance = getStringRequestUtils::createTypeData(s1    ,s2    );
    returnedValue = getString_Service->execute(instance, retInstance, m_timeout);
    switch (returnedValue)
    {
        case CLIENT_ERROR:
            printf("CLIENT ERROR\n");
            break;
        case RECEIVED_OTHER_REQUEST:
            printf("Y ESTE PAQUETE?\n");
            break;
        case SERVER_TIMEOUT:
            printf("TIMEOUT\n");
            break;
        case SERVER_ERROR:
            printf("SERVER ERROR\n");
            break;
        case WITHOUT_RESOURCES:
            printf("SERVER WITHOUT RESOURCES\n");
            break;
        case OPERATION_SUCCESSFUL:
            getStringReplyUtils::extractTypeData(retInstance, s2    ,s3    , getString_ret    );
            //getStringReplyTypeSupport::print_data(retInstance);          
            break;
    };
    
    getStringReplyTypeSupport::delete_data(retInstance);
    getStringRequestTypeSupport::delete_data(instance);

    return returnedValue;
}
 
DDSCSMessages
 SequenceTestProxy::getStringBounded(dattos & sb1 ,dattos  &sb2,dattos  &sb3, dattos  &getStringBounded_ret) 
{
    DDSCSMessages  returnedValue ;    
    getStringBoundedRequest *instance = NULL;
    getStringBoundedReply *retInstance = getStringBoundedReplyTypeSupport::create_data();
    instance = getStringBoundedRequestUtils::createTypeData(sb1    ,sb2    );
    returnedValue = getStringBounded_Service->execute(instance, retInstance, m_timeout);
    switch (returnedValue)
    {
        case CLIENT_ERROR:
            printf("CLIENT ERROR\n");
            break;
        case RECEIVED_OTHER_REQUEST:
            printf("Y ESTE PAQUETE?\n");
            break;
        case SERVER_TIMEOUT:
            printf("TIMEOUT\n");
            break;
        case SERVER_ERROR:
            printf("SERVER ERROR\n");
            break;
        case WITHOUT_RESOURCES:
            printf("SERVER WITHOUT RESOURCES\n");
            break;
        case OPERATION_SUCCESSFUL:
            getStringBoundedReplyUtils::extractTypeData(retInstance, sb2    ,sb3    , getStringBounded_ret    );
            //getStringBoundedReplyTypeSupport::print_data(retInstance);          
            break;
    };
    
    getStringBoundedReplyTypeSupport::delete_data(retInstance);
    getStringBoundedRequestTypeSupport::delete_data(instance);

    return returnedValue;
}
