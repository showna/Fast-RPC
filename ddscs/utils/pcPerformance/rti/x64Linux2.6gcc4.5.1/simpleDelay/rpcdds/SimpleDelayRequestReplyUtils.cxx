/*************************************************************************
 * Copyright (c) 2012 eProsima. All rights reserved.
 *
 * This copy of RPCDDS is licensed to you under the terms described in the
 * RPCDDS_LICENSE file included in this distribution.
 *
 *************************************************************************
 * 
 * @file SimpleDelayRequestReplyUtils.cxx
 * This source file contains the definition of helpful functions for the DDS messages for interface SimpleDelay.
 *
 * This file was generated by the tool rpcddsgen.
 */

#include "SimpleDelayRequestReplyUtils.h"
#include "SimpleDelayRequestReplyPlugin.h"


const char* SimpleDelay_sumaRequestUtils::registerType(DDS::DomainParticipant *participant)
{
    const char *typeName = NULL;

    if(participant != NULL)
    {
        typeName = SimpleDelay_sumaRequestTypeSupport::get_type_name();

        if(SimpleDelay_sumaRequestTypeSupport::register_type(participant, typeName) != DDS::RETCODE_OK)
        {
            return NULL;
        }
    }

    return typeName;
}

void SimpleDelay_sumaRequestUtils::setTypeData(SimpleDelay_sumaRequest& instance, /*in*/ DDS_Long value1, /*in*/ DDS_Long value2)
{
    instance.value1 = value1;
    instance.value2 = value2;
    
}

void SimpleDelay_sumaRequestUtils::extractTypeData(SimpleDelay_sumaRequest& data, /*in*/ DDS_Long& value1, /*in*/ DDS_Long& value2)
{
    value1 = data.value1;
    value2 = data.value2;  
    
}


const char* SimpleDelay_sumaReplyUtils::registerType(DDS::DomainParticipant *participant)
{
    const char *typeName = NULL;

    if(participant != NULL)
    {
        typeName = SimpleDelay_sumaReplyTypeSupport::get_type_name();

        if(SimpleDelay_sumaReplyTypeSupport::register_type(participant, typeName) != DDS::RETCODE_OK)
        {
            return NULL;
        }
    }

    return typeName;
}

void SimpleDelay_sumaReplyUtils::setTypeData(SimpleDelay_sumaReply& instance, /*out*/ DDS_Long suma_ret)
{
    instance.suma_ret = suma_ret;            
}

void SimpleDelay_sumaReplyUtils::extractTypeData(SimpleDelay_sumaReply& data, eProsima::RPCDDS::ReturnMessage& retcode, /*out*/ DDS_Long& suma_ret)
{
retcode = (eProsima::RPCDDS::ReturnMessage)data.header.rpcddsRetCode;
  
    suma_ret = data.suma_ret;            
}


const char* SimpleDelay_duplicateRequestUtils::registerType(DDS::DomainParticipant *participant)
{
    const char *typeName = NULL;

    if(participant != NULL)
    {
        typeName = SimpleDelay_duplicateRequestTypeSupport::get_type_name();

        if(SimpleDelay_duplicateRequestTypeSupport::register_type(participant, typeName) != DDS::RETCODE_OK)
        {
            return NULL;
        }
    }

    return typeName;
}

void SimpleDelay_duplicateRequestUtils::setTypeData(SimpleDelay_duplicateRequest& instance, /*in*/ const Estructura& es)
{
    instance.es = es;
    
}

void SimpleDelay_duplicateRequestUtils::extractTypeData(SimpleDelay_duplicateRequest& data, /*in*/ Estructura& es)
{
    es = data.es;  
    
}


const char* SimpleDelay_duplicateReplyUtils::registerType(DDS::DomainParticipant *participant)
{
    const char *typeName = NULL;

    if(participant != NULL)
    {
        typeName = SimpleDelay_duplicateReplyTypeSupport::get_type_name();

        if(SimpleDelay_duplicateReplyTypeSupport::register_type(participant, typeName) != DDS::RETCODE_OK)
        {
            return NULL;
        }
    }

    return typeName;
}

void SimpleDelay_duplicateReplyUtils::setTypeData(SimpleDelay_duplicateReply& instance, /*out*/ const Estructura& duplicate_ret)
{
    instance.duplicate_ret = duplicate_ret;            
}

void SimpleDelay_duplicateReplyUtils::extractTypeData(SimpleDelay_duplicateReply& data, eProsima::RPCDDS::ReturnMessage& retcode, /*out*/ Estructura& duplicate_ret)
{
retcode = (eProsima::RPCDDS::ReturnMessage)data.header.rpcddsRetCode;
  
    duplicate_ret = data.duplicate_ret;            
}

 