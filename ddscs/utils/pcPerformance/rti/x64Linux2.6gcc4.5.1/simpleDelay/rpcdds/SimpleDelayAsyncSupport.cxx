/*************************************************************************
 * Copyright (c) 2012 eProsima. All rights reserved.
 *
 * This copy of RPCDDS is licensed to you under the terms described in the
 * RPCDDS_LICENSE file included in this distribution.
 *
 *************************************************************************
 * 
 * @file SimpleDelayAsyncSupport.cxx
 * This source file contains functionality to use asynchronous calls for interface SimpleDelay.
 *
 * This file was generated by the tool rpcddsgen.
 */

#include "SimpleDelayProxy.h"
#include "SimpleDelayAsyncSupport.h"
#include "exceptions/ServerInternalException.h"
#include "SimpleDelayRequestReplyPlugin.h"


SimpleDelay_sumaTask::SimpleDelay_sumaTask(SimpleDelay_sumaCallbackHandler &obj,
   eProsima::RPCDDS::Client *client) : AsyncTask(client), m_obj(obj)
{
    SimpleDelay_sumaReply_initialize(&m_reply);
}

SimpleDelay_sumaTask::~SimpleDelay_sumaTask()
{
    SimpleDelay_sumaReply_finalize(&m_reply);
}

SimpleDelay_sumaCallbackHandler& SimpleDelay_sumaTask::getObject()
{
    return m_obj;
}

void* SimpleDelay_sumaTask::getReplyInstance()
{
    return &m_reply;
}

void SimpleDelay_sumaTask::execute()
{  
    DDS_Long  suma_ret = 0;
    eProsima::RPCDDS::ReturnMessage retcode = eProsima::RPCDDS::OPERATION_SUCCESSFUL;
	
	SimpleDelay_sumaReplyUtils::extractTypeData(m_reply, retcode, suma_ret);
		
	if(retcode == eProsima::RPCDDS::OPERATION_SUCCESSFUL)
	{
		getObject().suma(suma_ret);
	}
	else
	{
		if(retcode == eProsima::RPCDDS::SERVER_INTERNAL_ERROR)
		    getObject().on_exception(eProsima::RPCDDS::ServerInternalException(m_reply.header.rpcddsRetMsg));
	}
}

void SimpleDelay_sumaTask::on_exception(const eProsima::RPCDDS::SystemException &ex)
{
    getObject().on_exception(ex);
}


SimpleDelay_duplicateTask::SimpleDelay_duplicateTask(SimpleDelay_duplicateCallbackHandler &obj,
   eProsima::RPCDDS::Client *client) : AsyncTask(client), m_obj(obj)
{
    SimpleDelay_duplicateReply_initialize(&m_reply);
}

SimpleDelay_duplicateTask::~SimpleDelay_duplicateTask()
{
    SimpleDelay_duplicateReply_finalize(&m_reply);
}

SimpleDelay_duplicateCallbackHandler& SimpleDelay_duplicateTask::getObject()
{
    return m_obj;
}

void* SimpleDelay_duplicateTask::getReplyInstance()
{
    return &m_reply;
}

void SimpleDelay_duplicateTask::execute()
{  
    Estructura duplicate_ret;
    eProsima::RPCDDS::ReturnMessage retcode = eProsima::RPCDDS::OPERATION_SUCCESSFUL;
	
	SimpleDelay_duplicateReplyUtils::extractTypeData(m_reply, retcode, duplicate_ret);
		
	if(retcode == eProsima::RPCDDS::OPERATION_SUCCESSFUL)
	{
		getObject().duplicate(duplicate_ret);
	}
	else
	{
		if(retcode == eProsima::RPCDDS::SERVER_INTERNAL_ERROR)
		    getObject().on_exception(eProsima::RPCDDS::ServerInternalException(m_reply.header.rpcddsRetMsg));
	}
}

void SimpleDelay_duplicateTask::on_exception(const eProsima::RPCDDS::SystemException &ex)
{
    getObject().on_exception(ex);
}
