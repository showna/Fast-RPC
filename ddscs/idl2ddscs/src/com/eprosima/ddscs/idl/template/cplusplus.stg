/* $Id$   *
 * (c) Copyright, eProsima, 2009.                                          *
 * All rights reserved.                                                    *    
 *                                                                         *
 * No duplications, whole or partial, manual or electronic, may be made    *
 * without express written permission.  Any such copies, or                *
 * revisions thereof, must display this notice unaltered.                  *
 * This code contains trade secrets of                                     *
 * eProsima (Proyectos y Sistemas de Mantenimiento S.L.)                   *
 *                                                                         *
 * modification history                                                    *
 * --------------------                                                    *
 * 1.0,29sep09,RodM Created                                                *
 * =====================================================================   *
 */

group cplusplus;

typeInitMap ::= [
        "char":"DDS_Char",
        "wchar":"DDS_Wchar",
        "octet":"DDS_Octet",
        "short":"DDS_Short",
        "unsigned short":"DDS_UnsignedShort",
        "long":"DDS_Long",
        "unsigned long":"DDS_UnsignedLong",
        "long long":"DDS_LongLong",
        "unsigned long long":"DDS_UnsignedLongLong",
        "float":"DDS_Float",
        "double":"DDS_Double",
        "long double":"DDS_LongDouble",
        "boolean":"DDS_Boolean",
        "string":"char*",
        default:
]

doNotEditC(version="1.0") ::= <<
/** 
 * Generated by DDSCS: Do not edit.  Version $version$ *
 */
>>
doNotEditCplusplus(version="1.0") ::= <<
// 
// Generated by DDSCS: Do not edit.  Version $version$ *
//
>>

voidInitMap ::= [
        "void":"void",
        default: // anything other than an atomic type
]

returnVarDecl(type, retName) ::= <<
$if(!voidInitMap.(type))$
$if(typeInitMap.(type))$
$typeInitMap.(type)$  $retName$;
$else$
$type$ *$retName$ = $type$PluginSupport_create_data();
$endif$    
$endif$
>>
argType(type) ::= <<
$if(typeInitMap.(type))$
$typeInitMap.(type)$
$else$
$type$
$endif$
>>

argDecl(arg) ::= <<
$arg:{n | $argType(n.type)$ $n.name$};separator=", "$
>>

argDeclRef(arg) ::= <<
$arg:{n | $argType(n.type)$ &$n.name$};separator=", "$
>>

functionReturnType(type) ::= <<
$if(typeInitMap.(type))$
$typeInitMap.(type)$
$elseif(voidInitMap.(type))$
$voidInitMap.(type)$
$else$
$type$*
$endif$
>>

lastParam(params, type) ::= <<
$if(params)$
$if(!voidInitMap.(type))$, $endif$
$endif$
$if(!voidInitMap.(type))$
$if(!typeInitMap.(type))$*$endif$returnedValue$endif$
$endif$
>>

nextParam(previous, params) ::= <<
$if(previous)$
$if(params)$, 
$endif$
$endif$
$params:{$it.name$}; separator=", "$
>>

functionHeader(type,class,name,inputParams,inoutParams,outputParams) ::= << 
$functionReturnType(type)$ $class$$if(class)$::$endif$$name$($argDecl(inputParams);separator=", "$ $if(inoutParams)$,
              $endif$$argDeclRef(inoutParams);separator=", "$$if(outputParams)$,
              $endif$$argDeclRef(outputParams);separator=", "$)
>>

include(funNames) ::= <<
$funNames:{
#include "$it$RequestUtils.h"
#include "$it$ReplyUtils.h"
}$
>>
