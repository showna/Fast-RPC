/* $Id$   *
 * (c) Copyright, eProsima, 2009.                                          *
 * All rights reserved.                                                    *    
 *                                                                         *
 * No duplications, whole or partial, manual or electronic, may be made    *
 * without express written permission.  Any such copies, or                *
 * revisions thereof, must display this notice unaltered.                  *
 * This code contains trade secrets of                                     *
 * eProsima (Proyectos y Sistemas de Mantenimiento S.L.)                   *
 *                                                                         *
 * modification history                                                    *
 * --------------------                                                    *
 * 1.0,29sep09,RodM Created                                                *
 * =====================================================================   *
 */

group Proxy : cplusplus;

/************************************************************************
 *                                                                      *
 *   External Templates: Templates required to generate the Proxy       *
 *                                                                      *
 ************************************************************************
 */

/**
 * header: External Template
 * Produces the Proxy header file.
 * Params:
 *   interfaceName: Name of the interface whose methods this proxy invokes.
 *   funNames     : list of the interface function names. 
 *   funDecls     : list of functionHeader(cplusplus) template outputs.
 *
 * Uses:
 *  include - inherited(cplusplus)
 */ 
header(interfaceName, qosLibrary, qosProfile, funNames, funDecls) ::= <<
#ifndef _$interfaceName;format="toUpper"$_PROXY_H_
#define _$interfaceName;format="toUpper"$_PROXY_H_

$doNotEditC()$

#include "client/DDSCSClient.h"
#include "$interfaceName$RequestReplyUtils.h"
#include "$interfaceName$ClientRemoteServiceSupport.h"

class $interfaceName$Proxy : public DDSCSClient
{
    public:

        /// \brief The default constructor.
        $interfaceName$Proxy(int domainId = 0, unsigned int timeout = 3000,
        const char *qosLibrary =  $if(qosLibrary)$"$qosLibrary$"$else$NULL$endif$, const char *qosProfile = $if(qosProfile)$"$qosProfile$"$else$NULL$endif$);

        /// \brief The default destructor.
        virtual ~$interfaceName$Proxy();

        unsigned int getTimeout();
        void setTimeout(unsigned int millis);
        
        $funDecls; separator=";\n"$;
        
    private:
        $funNames:{ClientRemoteService *$it$_Service;};separator="\n"$ 
        
        unsigned int m_timeout;
};

#endif // _$interfaceName$_PROXY_H_
>>

/**
 * functionImpl: External Template
 * Produces the code required to call a function on the server.
 * Params:
 *   interfaceName: Name of the interface whose this function belongs to.
 *   type:         function return type.
 *   name:         function name. 
 *   inputParams:  list of input params objects.
 *   inoutParams:  list of inout params objects.
 *   outputParams: list of output params objects.
 *
 * Uses:
 *  voidInitMap           - inherited(cplusplus)
 *  varDecl               - inherited(cplusplus)
 *  nextParam             - inherited(cplusplus)
 *  extractTypeDataParams - inherited(cplusplus)
 */ 
functionImpl(interfaceName,type,name,inputParams,inoutParams,outputParams) ::= <<
$functionHeader(class={$interfaceName$Proxy},...)$ 
{
    $varDecl(type=type, name="returnedValue", create="yes")$
    $name$Request *instance = NULL;
    $name$Reply *retInstance = $name$ReplyTypeSupport::create_data();
    instance = $name$RequestUtils::createTypeData($nextExtractParam(params=inputParams)$$nextExtractParam(previous=inputParams, params=inoutParams)$);
    returnedValue = $name$_Service->execute(instance, retInstance, m_timeout);
    switch (returnedValue)
    {
        case CLIENT_ERROR:
            printf("CLIENT ERROR\n");
            break;
        case RECEIVED_OTHER_REQUEST:
            printf("Y ESTE PAQUETE?\n");
            break;
        case SERVER_TIMEOUT:
            printf("TIMEOUT\n");
            break;
        case SERVER_ERROR:
            printf("SERVER ERROR\n");
            break;
        case WITHOUT_RESOURCES:
            printf("SERVER WITHOUT RESOURCES\n");
            break;
        case OPERATION_SUCCESSFUL:
            $name$ReplyUtils::extractTypeData(retInstance$if([inoutParams, outputParams])$, $extractTypeDataParams(inoutParams=inoutParams, outputParams=outputParams)$$endif$);
            //$name$ReplyTypeSupport::print_data(retInstance);          
            break;
    };
    
    $name$ReplyTypeSupport::delete_data(retInstance);
    $name$RequestTypeSupport::delete_data(instance);

    $if(!voidInitMap.(type))$
    return returnedValue;
    $endif$
}
>>

/**
 * definition: External Template
 * Produces the Proxy implementation file.
 * Params:
 *   interfaceName: Name of the interface whose methods this proxy invokes.
 *   funNames     : list of the interface function names. 
 *   funImpls     : list of functionImpl template outputs.
 *
 * Uses:
 *  createRemoteService - local
 */ 
definition(interfaceName, funNames, funImpls) ::= <<
$doNotEditC()$


#include "$interfaceName$Proxy.h"
#include "client/ClientRemoteService.h"
#include "$interfaceName$RequestReplyPlugin.h"


$interfaceName$Proxy::$interfaceName$Proxy(int domainId, unsigned int timeout
, const char *qosLibrary, const char *qosProfile) : DDSCSClient(domainId, qosLibrary, qosProfile)
{
    m_timeout = timeout;
    $createRemoteService(funNames); separator="\n"$
}

$interfaceName$Proxy::~$interfaceName$Proxy()
{
    $funNames:{delete $it.name$_Service;}; separator="\n"$
}

unsigned int $interfaceName$Proxy::getTimeout()
{
  return m_timeout;
}
 
 void $interfaceName$Proxy::setTimeout(unsigned int millis)
 {
    m_timeout = millis;
 }

$funImpls; separator="\n"$
>>

/**
 * functionCall: External Template
 * Produces the code to invoke a function on the proxy object.
 * Declares the required local variables (uninitialized!!!) and use them as params. 
 * Params:
 *   type:         function return type.
 *   name:         function name. 
 *   inputParams:  list of input params objects.
 *   inoutParams:  list of inout params objects.
 *   outputParams: list of output params objects.
 *
 * Uses:
 *  voidInitMap   - inherited(cplusplus)
 *  varDecl       - inherited(cplusplus)
 */ 
functionCall(type,name,string,inputParams,inoutParams,outputParams) ::= <<
    $inputParams:{$varDecl(type = it.type, name = it.name, create="yes", string = it.string)$}; separator="\n"$   
    $inoutParams:{$varDecl(type = it.type, name = it.name, create="yes", string = it.string)$}; separator="\n"$   
    $outputParams:{$varDecl(type = it.type, name = it.name, create="yes", string = it.string)$}; separator="\n"$   
    $varDecl(type=type, name=[name,"RetValue"])$    

    /**
     * Dynamic memory passed to the proxy will be freed before return *
     * Pass a copy if you want to keep it                             *
     */
    $if(!voidInitMap.(type))$
    $name$RetValue = 
    $endif$proxy->$name$($nextParam(params=inputParams)$$nextParam(previous=inputParams, params=inoutParams)$$nextParam(previous=[inputParams,inoutParams], params=outputParams)$);
    
    $inputParams:{$varDel(type = it.type, name = it.name, string = it.string)$}; separator="\n"$
    $inoutParams:{$varDel(type = it.type, name = it.name, string = it.string)$}; separator="\n"$
    $outputParams:{$varDel(type = it.type, name = it.name, string = it.string)$}; separator="\n"$
>>

/**
 * main: External Template
 * Generates an example client program
 * Params:
 *   interfaceName: Name of the interface whose methods this client invokes.
 *   invocations:   List of functionCall template outputs. 
 *
 */ 
main(interfaceName, invocations) ::= <<
/** 
 * Generated by DDSCS                                                    *
 * Example client. Method params should be initialized before execution  *
 */

#include "$interfaceName$Proxy.h"
#include "$interfaceName$RequestReplyPlugin.h"

int main()
{
    int domainId = 0;
    unsigned int timeoutInMillis = 4000;
    $interfaceName$Proxy *proxy = new $interfaceName$Proxy(domainId, timeoutInMillis);
    DDS_Duration_t period = {5,0};
    
$invocations; separator="\n"$

   delete(proxy);
   NDDSUtility::sleep(period);
}
>>

/************************************************************************
 *                                                                      *
 *   Internal Templates: For internal use only.                         *
 *                                                                      *
 ************************************************************************
 */


/**
 * createRemoteService: Internal Template
 * Produces a list of DDSCSClient inherited createRemoteService  method calls.
 * required to initialize this proxy object.
 * Params:
 *   funNames     : list of the interface function names. 
 *
 * Uses:
 */ 
createRemoteService(funNames) ::= <<
$funNames:{this->$it.name$_Service = new $it.name$ClientRemoteService("$it.name$",
                              $it.name$RequestUtils::registerType(getParticipant()),
                              $if(it.requestQosLibrary)$"$it.requestQosLibrary$"$else$NULL$endif$,
                              $if(it.requestQosProfile)$"$it.requestQosProfile$"$else$NULL$endif$,
                              $it.name$ReplyUtils::registerType(getParticipant()),
                              $if(it.replyQosLibrary)$"$it.replyQosLibrary$"$else$NULL$endif$,
                              $if(it.replyQosProfile)$"$it.replyQosProfile$"$else$NULL$endif$,
                              getParticipant());
}$
>>


/**
 * lastParam: Internal Template
 * Determines if the return value of the function should be included
 * in a call to RequestUtils extractTypeData method.
 * Params:
 *   params   : List of previous arguments in the function call. Nullable.
 *   type     :         function return type.
 *
 * Uses:
 *   voidInitMap - inherited(cplusplus)
 *   typeInitMap - inherited(cplusplus) 
 */ 
lastParam(params, type) ::= <<
$if(params)$
$if(!voidInitMap.(type))$, $endif$
$endif$
$if(!voidInitMap.(type))$
$if(!typeInitMap.(type))$*$endif$returnedValue$endif$
$endif$
>>

/**
 * extractTypeDataParams: Internal Template
 * Produces the params for calling RequestUtils extractTypeData method 
 * Params:
 *   inoutParams  : list of inout params objects.
 *   outputParams : list of output params objects.
 *
 * Uses:
 *  nextExtractParam - local
 */ 
extractTypeDataParams(inoutParams, outputParams) ::= <<
$[nextExtractParam(params=inoutParams),nextExtractParam(previous=inoutParams, params=outputParams)]$
>>

/**
 * varExtractUse: Internal Template
 * Uses the variable as a parameter to a funcion call 
 * checking if ti is a pointer or not. 
 * Params:
 *   type     : Variable type.
 *   name     : Variable name. 
 *
 * Uses:
 */ 
 varExtractUse(type, name) ::= <<
$if(typeInitMap.(type))$$name$
$else$
$name$
$endif$    
>>


/**
 * nextExtractParam: Internal Template
 * Adds arguments to a function call preceeding them by a comma
 * if there are previous arguments. 
 * Params:
 *   previous   : List of previous arguments in the function call. Nullable.
 *   params     : List of next arguments in the function call. Nullable.
 *
 * Uses:
 */ 
 nextExtractParam(previous, params) ::= <<
$if(previous)$
$if(params)$,
$endif$
$endif$
$params:{$varExtractUse(type = it.type, name = it.name)$};separator=", "$
>>
