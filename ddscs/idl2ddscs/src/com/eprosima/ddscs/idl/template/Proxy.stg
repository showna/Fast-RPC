/* $Id$   *
 * (c) Copyright, eProsima, 2009.                                          *
 * All rights reserved.                                                    *    
 *                                                                         *
 * No duplications, whole or partial, manual or electronic, may be made    *
 * without express written permission.  Any such copies, or                *
 * revisions thereof, must display this notice unaltered.                  *
 * This code contains trade secrets of                                     *
 * eProsima (Proyectos y Sistemas de Mantenimiento S.L.)                   *
 *                                                                         *
 * modification history                                                    *
 * --------------------                                                    *
 * 1.0,29sep09,RodM Created                                                *
 * =====================================================================   *
 */

group Proxy : cplusplus;

/************************************************************************
 *                                                                      *
 *   External Templates: Templates required to generate the Proxy       *
 *                                                                      *
 ************************************************************************
 */

/**
 * header: External Template
 * Produces the Proxy header file.
 * Params:
 *   interfaceName: Name of the interface whose methods this proxy invokes.
 *   funNames     : list of the interface function names. 
 *   funDecls     : list of functionHeader(cplusplus) template outputs.
 *
 * Uses:
 *  include - inherited(cplusplus)
 */ 
header(interfaceName,funNames, funDecls) ::= <<
#ifndef _$interfaceName;format="toUpper"$PROXY_H_
#define _$interfaceName;format="toUpper"$PROXY_H_

$doNotEditC()$

#include "client/DDSCSClient.h"
$include(funNames); separator="\n"$

class ClientRemoteService;

class $interfaceName$Proxy : public DDSCSClient
{
    public:

        /// \brief The default constructor.
        $interfaceName$Proxy();

        /// \brief The default destructor.
        virtual ~$interfaceName$Proxy();

        $funDecls; separator=";\n"$;
        
    private:
        $funNames:{ClientRemoteService *$it$_Service;};separator="\n"$ 
};

#endif // _$interfaceName$PROXY_H_
>>

/**
 * functionImpl: External Template
 * Produces the code required to call a function on the server.
 * Params:
 *   interfaceName: Name of the interface whose this function belongs to.
 *   type:         function return type.
 *   name:         function name. 
 *   inputParams:  list of input params objects.
 *   inoutParams:  list of inout params objects.
 *   outputParams: list of output params objects.
 *
 * Uses:
 *  voidInitMap           - inherited(cplusplus)
 *  varDecl               - inherited(cplusplus)
 *  nextParam             - inherited(cplusplus)
 *  extractTypeDataParams - inherited(cplusplus)
 */ 
functionImpl(interfaceName,type,name,inputParams,inoutParams,outputParams) ::= <<
$functionHeader(class={$interfaceName$Proxy},...)$ 
{
    DDSCSMessages retValue;
    $varDecl(type=type, name="returnedValue", create="yes")$    
    $name$Request *instance = NULL;
    $name$Reply *retInstance = ($name$Reply*)$name$ReplyUtils::createEmptyData();
    instance = $name$RequestUtils::createTypeData($inputParams:{$it.name$}; separator=","$$nextParam(previous=inputParams, params=inoutParams)$);
    // Protects from multithread access
    $name$_Service->take();
    retValue = $name$_Service->execute(instance);
    if(retValue == OPERATION_SUCCESSFUL)
    {
      int ret = $name$_Service->getServerReply(instance, retInstance);
      retValue = (ret == 0 ? (DDSCSMessages)((long*)retInstance)[2]: RECEIVED_OTHER_REQUEST);
    }
    $name$_Service->give();
    switch (retValue)
    {
        case CLIENT_ERROR:
            printf("CLIENT ERROR\n");
            break;
        case RECEIVED_OTHER_REQUEST:
            printf("Y ESTE PAQUETE?\n");
            break;
        case SERVER_TIMEOUT:
            printf("TIMEOUT\n");
            break;
        case SERVER_ERROR:
            printf("SERVER ERROR\n");
            break;
        case WITHOUT_RESOURCES:
            printf("SERVER WITHOUT RESOURCES\n");
            break;
        case OPERATION_SUCCESSFUL:
            $name$ReplyUtils::extractTypeData(retInstance$if(extractTypeDataParams(type=type,...))$, $extractTypeDataParams(type=type,...)$$endif$);
            $name$ReplyTypeSupport::print_data(retInstance);
            break;
    };
    $name$ReplyUtils::deleteData(retInstance);
    $name$RequestUtils::deleteData(instance);

    $if(!voidInitMap.(type))$
    return returnedValue;
    $endif$
}
>>

/**
 * definition: External Template
 * Produces the Proxy implementation file.
 * Params:
 *   interfaceName: Name of the interface whose methods this proxy invokes.
 *   funNames     : list of the interface function names. 
 *   funImpls     : list of functionImpl template outputs.
 *
 * Uses:
 *  createRemoteService - local
 */ 
definition(interfaceName,funNames, funImpls) ::= <<
$doNotEditC()$


#include "$interfaceName$Proxy.h"
#include "client/ClientRemoteService.h"
#include "$interfaceName$Plugin.h"


$interfaceName$Proxy::$interfaceName$Proxy() : DDSCSClient()
{
    $createRemoteService(funNames); separator="\n"$
}

$interfaceName$Proxy::~$interfaceName$Proxy()
{
    $funNames:{name|delete $name$_Service;}; separator="\n"$
}

$funImpls; separator="\n"$
>>

/**
 * functionCall: External Template
 * Produces the code to invoke a function on the proxy object.
 * Declares the required local variables (uninitialized!!!) and use them as params. 
 * Params:
 *   type:         function return type.
 *   name:         function name. 
 *   inputParams:  list of input params objects.
 *   inoutParams:  list of inout params objects.
 *   outputParams: list of output params objects.
 *
 * Uses:
 *  voidInitMap   - inherited(cplusplus)
 *  varDecl       - inherited(cplusplus)
 */ 
functionCall(type,name,inputParams,inoutParams,outputParams) ::= <<
    $inputParams:{$varDecl(type = it.type, name = it.name, create="yes")$}; separator="\n"$   
    $inoutParams:{$varDecl(type = it.type, name = it.name, create="yes")$}; separator="\n"$   
    $outputParams:{$varDecl(type = it.type, name = it.name, create="yes")$}; separator="\n"$   
    $varDecl(type=type, name=[name,"RetValue"])$    

    /**
     * Dynamic memory passed to the proxy will be freed before return *
     * Pass a copy if you want to keep it                             *
     */
    $if(!voidInitMap.(type))$
    $name$RetValue = 
    $endif$proxy->$name$($nextParam(params=inputParams)$$nextParam(previous=inputParams, params=inoutParams)$$nextParam(previous=[inputParams,inoutParams], params=outputParams)$);

>>

/**
 * main: External Template
 * Generates an example client program
 * Params:
 *   interfaceName: Name of the interface whose methods this client invokes.
 *   invocations:   List of functionCall template outputs. 
 *
 */ 
main(interfaceName, invocations) ::= <<
/** 
 * Generated by DDSCS                                                    *
 * Example client. Method params should be initialized before execution  *
 */

#include "$interfaceName$Proxy.h"
#include "$interfaceName$Plugin.h"

int main()
{
    $interfaceName$Proxy *proxy = new $interfaceName$Proxy();
$invocations; separator="\n"$
}
>>

/************************************************************************
 *                                                                      *
 *   Internal Templates: For internal use only.                         *
 *                                                                      *
 ************************************************************************
 */

/**
 * createRemoteService: Internal Template
 * Produces a list of DDSCSClient inherited createRemoteService  method calls.
 * required to initialize this proxy object.
 * Params:
 *   funNames     : list of the interface function names. 
 *
 * Uses:
 */ 
createRemoteService(funNames) ::= <<
$funNames:{funName |
    this->$funName$_Service = new ClientRemoteService("$funName$",
                              getClientId(),
                              $funName$RequestUtils::registerType(getParticipant()),
                              $funName$ReplyUtils::registerType(getParticipant()),
                              getParticipant());
}$
>>


/**
 * lastParam: Internal Template
 * Determines if the return value of the function should be included
 * in a call to RequestUtils extractTypeData method.
 * Params:
 *   params   : List of previous arguments in the function call. Nullable.
 *   type     :         function return type.
 *
 * Uses:
 *   voidInitMap - inherited(cplusplus)
 *   typeInitMap - inherited(cplusplus) 
 */ 
lastParam(params, type) ::= <<
$if(params)$
$if(!voidInitMap.(type))$, $endif$
$endif$
$if(!voidInitMap.(type))$
$if(!typeInitMap.(type))$*$endif$returnedValue$endif$
$endif$
>>

/**
 * extractTypeDataParams: Internal Template
 * Produces the params for calling RequestUtils extractTypeData method 
 * Params:
 *   type         : function return type.
 *   inputParams  : list of input params objects.
 *   inoutParams  : list of inout params objects.
 *   outputParams : list of output params objects.
 *
 * Uses:
 *  nextParam - inherited(cplusplus)
 *  lastParam - local
 */ 
extractTypeDataParams(type, inputParams, inoutParams, outputParams) ::= <<
$[nextParam(params=inoutParams),nextParam(previous=inoutParams, params=outputParams),lastParam(params=[inoutParams,outputParams],type=type)]$
>>