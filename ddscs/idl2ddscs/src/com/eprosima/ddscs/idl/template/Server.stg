/* $Id$   *
 * (c) Copyright, eProsima, 2009.                                          *
 * All rights reserved.                                                    *    
 *                                                                         *
 * No duplications, whole or partial, manual or electronic, may be made    *
 * without express written permission.  Any such copies, or                *
 * revisions thereof, must display this notice unaltered.                  *
 * This code contains trade secrets of                                     *
 * eProsima (Proyectos y Sistemas de Mantenimiento S.L.)                   *
 *                                                                         *
 * modification history                                                    *
 * --------------------                                                    *
 * 1.0,29sep09,RodM Created                                                *
 * =====================================================================   *
 */

group Server : cplusplus;


headerServer(interfaceName,funNames, funDecls) ::= <<
#ifndef _$interfaceName;format="toUpper"$SKELETON_H_
#define _$interfaceName;format="toUpper"$SKELETON_H_

$doNotEditC()$

#include "server/DDSCSServer.h"
#include "$interfaceName$ServerImpl.h"
$include(funNames); separator="\n"$

class $interfaceName$Server : public DDSCSServer
{
    private: 
      $interfaceName$Impl *_impl;
    public:

        /// \brief The default constructor.
        $interfaceName$Server();

        /// \brief The default destructor.
        virtual ~$interfaceName$Server();

        $funDecls; separator=";\n"$;
};

#endif // _$interfaceName$SKELETON_H_
>>

headerImpl(interfaceName, funNames, funDecls) ::= <<
#ifndef _$interfaceName;format="toUpper"$IMPL_H_
#define _$interfaceName;format="toUpper"$IMPL_H_

$doNotEditC()$

#include "$interfaceName$.h"

class $interfaceName$Impl
{
    public:

        /// \brief The default constructor.
        $interfaceName$Impl();

        /// \brief The default destructor.
        virtual ~$interfaceName$Impl();

        $funDecls; separator=";\n"$;
};

#endif // _$interfaceName$IMPL_H_
>>

returnType(type) ::= <<
$if(voidInitMap.(type))$
$elseif(typeInitMap.(type))$
$typeInitMap.(type)$ _ret_value_;
return _ret_value_;
$else$
$type$* _ret_value_ = new $type$();
return _ret_value_;
$endif$  
>>

emptyFunctionImpl(interfaceName,type,name,inputParams,inoutParams,outputParams) ::= <<
$functionHeader(class={$interfaceName$Impl},...)$ 
{
  $returnType(type)$
} 
>>

exFunctionHeader(type,class,name,inputParams,inoutParams,outputParams) ::= <<
$if(!class)$static $endif$void $class$$if(class)$Server::$endif$$name$(DDSCSServer *server, void *requestData)
>>

extractTypeDataParams(type, inputParams, inoutParams, outputParams) ::= <<
$[nextParam(params=inputParams),nextParam(previous=inputParams, params=inoutParams)]$
>>

functionImpl(interfaceName,type,name,inputParams,inoutParams,outputParams) ::= <<
$exFunctionHeader(class=interfaceName,...)$ 
{ 
    $interfaceName$Server *srv = ($interfaceName$Server*)server;
    $inputParams:{$argType(it.type)$ $it.name$;}; separator="\n"$   
    $inoutParams:{$argType(it.type)$ $it.name$;}; separator="\n"$   
    $outputParams:{$argType(it.type)$ $it.name$;}; separator="\n"$   
    $returnVarDecl(type=type, retName="returnedValue")$    
    $name$Reply *replyData = NULL;

    $name$RequestUtils::extractTypeData(($name$Request*)requestData$if(extractTypeDataParams(type=type,...))$, $extractTypeDataParams(type=type,...)$$endif$);
                                         
    srv->_impl->$name$($inputParams:{$it.name$}; separator=","$$nextParam(previous=inputParams, params=inoutParams)$$nextParam(previous=[inputParams,inoutParams], params=outputParams)$);
           
    replyData = $name$ReplyUtils::createTypeData($inoutParams:{$it.name$}; separator=", "$$nextParam(previous=inoutParams, params=outputParams)$$lastParam(params=[inoutParams,outputParams],type=type)$);
                                                  
    server->sendReply("$name$", requestData, replyData);
    $name$RequestUtils::deleteData(requestData);
    $name$ReplyUtils::deleteData(replyData);
}
>>

createRemoteService(interfaceName, funNames) ::= <<
$funNames:{funName |
    this->createRemoteService("$funName$", $funName$RequestUtils::registerType(getParticipant()),
            $funName$ReplyUtils::registerType(getParticipant()),
            $funName$RequestUtils::createEmptyData, $funName$RequestUtils::deleteData,
            $funName$ReplyUtils::createEmptyData, $funName$ReplyUtils::deleteData,
            &$interfaceName$Server::$funName$);
}$
>>



definitionServer(interfaceName, funNames, funImpls) ::= <<
$doNotEditC()$

#include "$interfaceName$Server.h"
#include "$interfaceName$Plugin.h"

$interfaceName$Server::$interfaceName$Server() : DDSCSServer()
{
    _impl = new $interfaceName$Impl();
    
    $createRemoteService(...); separator="\n"$
}
$interfaceName$Server::~$interfaceName$Server()
{
    delete _impl;    
}

$funImpls; separator="\n"$
>>

definitionImpl(interfaceName, funNames, funImpls) ::= <<
/** 
 * Generated by DDSCS                                               *
 * Empty interface implementation to be filled with your own code.  *
 */
 
#include "$interfaceName$ServerImpl.h"

$interfaceName$Impl::$interfaceName$Impl()
{
}
$interfaceName$Impl::~$interfaceName$Impl()
{
}

$funImpls; separator="\n"$
>>

functionCall(type,name,inputParams,inoutParams,outputParams) ::= <<
>>

main(interfaceName, invocations) ::= <<
/** 
 * Generated by DDSCS    *
 * Simplest server main  *
 */

#include "$interfaceName$Server.h"

int main()
{
    int returnedValue = 0;
    $interfaceName$Server *server = new $interfaceName$Server();
    server->executeServer();

    delete server;
}

>>
