/* $Id$   *
 * (c) Copyright, eProsima, 2009.                                          *
 * All rights reserved.                                                    *    
 *                                                                         *
 * No duplications, whole or partial, manual or electronic, may be made    *
 * without express written permission.  Any such copies, or                *
 * revisions thereof, must display this notice unaltered.                  *
 * This code contains trade secrets of                                     *
 * eProsima (Proyectos y Sistemas de Mantenimiento S.L.)                   *
 *                                                                         *
 * modification history                                                    *
 * --------------------                                                    *
 * 1.0,29sep09,RodM Created                                                *
 * =====================================================================   *
 */

group Server : cplusplus;

/************************************************************************
 *                                                                      *
 *   External Templates: Common Templates for C++ code generation       *
 *                                                                      *
 ************************************************************************
 */
/**
 * headerServer: External Template
 * Produces header file for a Server that handles requests and replies for an object that 
 * implements the interface defined in IDL.
 * 
 * Params:
 *   interfaceName : name of the interface.
 *   funNames      : List with the names of the interface methods.
 *   funDecls      : List whith the function headers - produced by 
 *                   exFunctionHeader template.
 *
 * Uses:
 *   include    - inherited(cplusplus)
 *   doNotEditC - inherited(cplusplus)
 */ 
headerServer(interfaceName,funNames, funDecls) ::= <<
#ifndef _$interfaceName;format="toUpper"$SKELETON_H_
#define _$interfaceName;format="toUpper"$SKELETON_H_

$doNotEditC()$

#include "server/DDSCSServer.h"
#include "$interfaceName$ServerImpl.h"
#include "$interfaceName$RequestReplyUtils.h"

class $interfaceName$Server : public DDSCSServer
{
    private: 
      $interfaceName$Impl *_impl;
    public:

        /// \brief The default constructor.
        $interfaceName$Server(int domainId = 0, const char *qosLibrary = NULL,
            const char *qosProfile = NULL, unsigned int threadCount = DDSCS_MIN_THREADS_DEFAULT);

        /// \brief The default destructor.
        virtual ~$interfaceName$Server();

        $funDecls; separator=";\n"$;
};

#endif // _$interfaceName$SKELETON_H_
>>

/**
 * headerImpl: External Template
 * Produces header file for a class that implements the interface defined in IDL.
 * 
 * Params:
 *   interfaceName : name of the interface.
 *   funNames      : List with the names of the interface methods.
 *   funDecls      : List whith the function headers - produced by 
 *                   inherited functionHeader template.
 *
 * Uses:
 *   doNotEditC - inherited(cplusplus)
 */ 
headerImpl(interfaceName, funNames, funDecls) ::= <<
#ifndef _$interfaceName;format="toUpper"$IMPL_H_
#define _$interfaceName;format="toUpper"$IMPL_H_

$doNotEditC()$

#include "utils/DDSCSMessages.h"
#include "$interfaceName$RequestReplyUtils.h"

class $interfaceName$Impl
{
    public:

        /// \brief The default constructor.
        $interfaceName$Impl();

        /// \brief The default destructor.
        virtual ~$interfaceName$Impl();

        $funDecls; separator=";\n"$;
};

#endif // _$interfaceName$IMPL_H_
>>

/**
 * emptyFunctionImpl: External Template
 * Empty implementation for a function. To be filled with user application code.
 * Params:
 *   interfaceName: Name of the interface whose this function belongs to.
 *   type:         function return type.
 *   name:         function name. 
 *   inputParams:  list of input params objects.
 *   inoutParams:  list of inout params objects.
 *   outputParams: list of output params objects.
 *
 * Uses:
 *  functionHeader - inherited(cplusplus)
 *  returnType     - local
 */ 
emptyFunctionImpl(interfaceName,type,name,inputParams,inoutParams,outputParams) ::= <<
$functionHeader(class={$interfaceName$Impl},...)$ 
{
  DDSCSMessages retCode = OPERATION_SUCCESSFUL;
  
  return retCode;
} 
>>

/**
 * functionImpl: External Template
 * Produces the code required to handle a request: 
 * Extracts request Data to local variables and use them to call implementation object.
 * Creates a reply Data object and fills it with the output values and sends it 
 *
 * Params:
 *   interfaceName: Name of the interface whose this function belongs to.
 *   type:         function return type.
 *   name:         function name. 
 *   inputParams:  list of input params objects.
 *   inoutParams:  list of inout params objects.
 *   outputParams: list of output params objects.
 *
 * Uses:
 *  varDecl               - inherited(cplusplus)
 *  nextParam             - inherited(cplusplus)
 *  lastParam             - inherited(cplusplus)
 *  extractTypeDataParams - inherited(cplusplus)
 */ 
functionImpl(interfaceName,type,name,string,inputParams,inoutParams,outputParams) ::= <<
$exFunctionHeader(class=interfaceName,...)$ 
{ 
    $interfaceName$Server *srv = ($interfaceName$Server*)server;
    $inputParams:{$varDecl(type = it.type, name = it.name, create="yes", string = it.string)$}; separator="\n"$   
    $inoutParams:{$varDecl(type = it.type, name = it.name, create="yes", string = it.string)$}; separator="\n"$   
    $outputParams:{$varDecl(type = it.type, name = it.name, create="yes", string = it.string)$}; separator="\n"$   
    $varDecl(type=type, name="returnedValue")$    
    $name$Reply *replyData = NULL;

    $name$RequestUtils::extractTypeData(($name$Request*)requestData$if([inputParams,inoutParams])$, $extractTypeDataParams(type=type,...)$$endif$);
                                         
    $if(!voidInitMap.(type))$
    returnedValue = $endif$srv->_impl->$name$($nextParam(params=inputParams)$$nextParam(previous=inputParams, params=inoutParams)$$nextParam(previous=[inputParams,inoutParams], params=outputParams)$);
           
    replyData = $name$ReplyUtils::createTypeData($nextParam(params=inoutParams)$$nextParam(previous=inoutParams, params=outputParams)$);
                                                  
    // sendReply takes care of deleting the data
    service->sendReply(requestData, replyData, returnedValue);
    
    $inputParams:{$varDel(type = it.type, name = it.name, string = it.string)$}; separator="\n"$
    $inoutParams:{$varDel(type = it.type, name = it.name, string = it.string)$}; separator="\n"$
    $outputParams:{$varDel(type = it.type, name = it.name, string = it.string)$}; separator="\n"$
}
>>

/**
 * definitionServer: External Template
 * Produces the Server implementation file.
 * Params:
 *   interfaceName: Name of the interface whose methods this proxy invokes.
 *   funNames     : list of the interface function names. 
 *   funImpls     : list of functionImpl template outputs.
 *
 * Uses:
 *   doNotEditC - inherited(cplusplus)
 *   createRemoteService - local
 */ 
definitionServer(interfaceName, funNames, funImpls) ::= <<
$doNotEditC()$

#include "$interfaceName$Server.h"
#include "$interfaceName$RequestReplyPlugin.h"
#include "$interfaceName$ServerRemoteServiceSupport.h"

$interfaceName$Server::$interfaceName$Server(int domainId, const char *qosLibrary,
    const char *qosProfile, unsigned int threadCount) : DDSCSServer(domainId, qosLibrary, qosProfile, threadCount)
{
    _impl = new $interfaceName$Impl();
    
    $createRemoteService(...); separator="\n"$
}
$interfaceName$Server::~$interfaceName$Server()
{
    delete _impl;    
}

$funImpls; separator="\n"$
>>

/**
 * definitionImpl: External Template
 * Produces the interface implementation file.
 * Params:
 *   interfaceName: Name of the interface whose methods this proxy invokes.
 *   funNames     : list of the interface function names. 
 *   funImpls     : list of emptyFunctionImpl template outputs.
 *
 * Uses:
 */ 
definitionImpl(interfaceName, funNames, funImpls) ::= <<
/** 
 * Generated by DDSCS                                               *
 * Empty interface implementation to be filled with your own code.  *
 */
 
#include "$interfaceName$ServerImpl.h"

$interfaceName$Impl::$interfaceName$Impl()
{
}
$interfaceName$Impl::~$interfaceName$Impl()
{
}

$funImpls; separator="\n"$
>>

/**
 * functionCall: External Template
 * Do nothing, just required to let the same code generating Proxy and Server.
 * Params:
 *   type:         function return type.
 *   name:         function name. 
 *   inputParams:  list of input params objects.
 *   inoutParams:  list of inout params objects.
 *   outputParams: list of output params objects.
 *
 * Uses:
 */ 
functionCall(type,name,inputParams,inoutParams,outputParams) ::= <<
>>

/**
 * main: External Template
 * Generates an example server program
 * Params:
 *   interfaceName: Name of the interface this server provides.
 *   invocations  : Not used. Just to have a common signature with functionHeader template. 
 *
 */ 
main(interfaceName, qosLibrary, qosProfile, invocations) ::= <<
/** 
 * Generated by DDSCS    *
 * Simplest server main  *
 */

#include "$interfaceName$Server.h"

int main()
{
    int returnedValue = 0;
    int domainId = 0;
    unsigned int threadPoolSize = 5;
    $interfaceName$Server *server = new $interfaceName$Server(domainId,
        $if(qosLibrary)$"$qosLibrary$"$else$NULL$endif$,
        $if(qosProfile)$"$qosProfile$"$else$NULL$endif$,
        threadPoolSize);
    server->executeServer();

    delete server;
}

>>

/************************************************************************
 *                                                                      *
 *   Internal Templates: For internal use only.                         *
 *                                                                      *
 ************************************************************************
 */

/**
 * returnType: Internal Template
 * Declares a variable of function Return Type if not void.
 * If it is an user defined type also initializes it;
 * Params:
 *   type     : Variable type.
 *
 * Uses:
 *   voidInitMap - local
 *   typeInitMap - local
 */ 
returnType(type) ::= <<
$if(voidInitMap.(type))$
$elseif(typeInitMap.(type))$
$typeInitMap.(type)$ _ret_value_;
return _ret_value_;
$else$
$type$* _ret_value_ = new $type$();
return _ret_value_;
$endif$  
>>

/**
 * lastParam: Internal Template
 * Determines if the return value of the function should be included
 * in a call to ReplyUtils createTypeData method.
 * Params:
 *   params   : List of previous arguments in the function call. Nullable.
 *   type     :         function return type.
 *
 * Uses:
 *   voidInitMap - inherited(cplusplus)
 *   typeInitMap - inherited(cplusplus) 
 */ 
lastParam(params, type) ::= <<
$if(params)$
$if(!voidInitMap.(type))$, $endif$
$endif$
$if(!voidInitMap.(type))$
$if(!typeInitMap.(type))$*$endif$returnedValue$endif$
$endif$
>>


/**
 * exFunctionHeader: External Template
 * Produces a function header to be used in declaration & implementation 
 * Params:
 *   type         : function return type.
 *   class        : Class name. Must be null for declaration and not null for implementation
 *   inputParams  : not used. Just to have a common signature with functionHeader template.
 *   inoutParams  : not used. Just to have a common signature with functionHeader template.
 *   outputParams : not used. Just to have a common signature with functionHeader template.
 *
 * Uses:
 */ 
exFunctionHeader(type,class,name,inputParams,inoutParams,outputParams) ::= <<
$if(!class)$static $endif$void $class$$if(class)$Server::$endif$$name$(DDSCSServer *server, void *requestData, ServerRemoteService *service)
>>

/**
 * extractTypeDataParams: Internal Template
 * Produces the params for calling Utils extractTypeData method 
 * Params:
 *   type         : function return type.
 *   inputParams  : list of input params objects.
 *   inoutParams  : list of inout params objects.
 *   outputParams : list of output params objects.
 *
 * Uses:
 *  nextParam - inherited(cplusplus)
 */ 
extractTypeDataParams(type, inputParams, inoutParams, outputParams) ::= <<
$[nextParam(params=inputParams),nextParam(previous=inputParams, params=inoutParams)]$
>>

/**
 * createRemoteService: Internal Template
 * Produces a list of DDSCSServer inherited createRemoteService  method calls.
 * required to initialize this server object.
 * Params:
 *   funNames     : list of the interface function names. 
 *
 * Uses:
 */
createRemoteService(interfaceName, funNames) ::= <<
$funNames:{this->setRemoteService(new $it.name$ServerRemoteService("$it.name$", this,
            $it.name$RequestUtils::registerType(getParticipant()),
            $if(it.requestQosLibrary)$"$it.requestQosLibrary$"$else$NULL$endif$,
            $if(it.requestQosProfile)$"$it.requestQosProfile$"$else$NULL$endif$,
            $it.name$ReplyUtils::registerType(getParticipant()),
            $if(it.replyQosLibrary)$"$it.replyQosLibrary$"$else$NULL$endif$,
            $if(it.replyQosProfile)$"$it.replyQosProfile$"$else$NULL$endif$,
            &$interfaceName$Server::$it.name$, getParticipant()));
}$
>>

