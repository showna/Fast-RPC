/** 
 * Generated by DDSCS: Do not edit.  Version 1.0 *
 */


#include "HelloWorldAsyncProxy.h"
#include "client/ClientRPC.h"
#include "transports/UDPTransport.h"
#include "transports/TCPTransport.h"
#include "HelloWorldAsyncRequestReplyPlugin.h"
#include "HelloWorldAsyncAsyncSupport.h"
#include "exceptions/Exceptions.h"

HelloWorldAsyncProxy::HelloWorldAsyncProxy(std::string remoteServiceName, int domainId, long timeout) :
    Client(remoteServiceName, NULL, domainId, timeout)
{
    createRPCs();
}

HelloWorldAsyncProxy::HelloWorldAsyncProxy(std::string remoteServiceName, eProsima::RPCDDS::Transport *transport, int domainId, long timeout) :
    Client(remoteServiceName, transport, domainId, timeout)
{
    createRPCs();
}

HelloWorldAsyncProxy::~HelloWorldAsyncProxy()
{
    delete sayHello_Service;
}

void HelloWorldAsyncProxy::createRPCs()
{
    this->sayHello_Service = new HelloWorldAsync_sayHelloClientRPC("sayHello",
                                  HelloWorldAsync_sayHelloRequestUtils::registerType(getParticipant()),
                                  HelloWorldAsync_sayHelloReplyUtils::registerType(getParticipant()),
                                  this);

}

 
char* HelloWorldAsyncProxy::sayHello(/*in*/ char* name) 
{
    eProsima::RPCDDS::ReturnMessage retcode = eProsima::RPCDDS::CLIENT_INTERNAL_ERROR;
    char*  sayHello_ret = NULL;    
    HelloWorldAsync_sayHelloRequest instance;
    HelloWorldAsync_sayHelloReply retInstance;

    HelloWorldAsync_sayHelloReply_initialize(&retInstance);    
    HelloWorldAsync_sayHelloRequestUtils::setTypeData(instance, name);
    retcode = sayHello_Service->execute(&instance, &retInstance, getTimeout());
    
    if(retcode == eProsima::RPCDDS::OPERATION_SUCCESSFUL)
    {
        HelloWorldAsync_sayHelloReplyUtils::extractTypeData(retInstance, retcode, sayHello_ret);  
    }
    
    switch (retcode)
    {
        case eProsima::RPCDDS::CLIENT_INTERNAL_ERROR:
            throw eProsima::RPCDDS::ClientInternalException("Error in client side");
            break;
        case eProsima::RPCDDS::NO_SERVER:
            throw eProsima::RPCDDS::ServerNotFoundException("Cannot connect to the server");
            break;
        case eProsima::RPCDDS::SERVER_TIMEOUT:
            throw eProsima::RPCDDS::ServerTimeoutException("Timeout waiting the server's reply");
            break;
        case eProsima::RPCDDS::SERVER_INTERNAL_ERROR:
            throw eProsima::RPCDDS::ServerInternalException(retInstance.header.rpcddsRetMsg);
            break;
    };
    

    return sayHello_ret;
}

 
void HelloWorldAsyncProxy::sayHello_async(HelloWorldAsync_sayHelloCallbackHandler &obj, /*in*/ char* name) 
{
	eProsima::RPCDDS::ReturnMessage retcode = eProsima::RPCDDS::CLIENT_INTERNAL_ERROR;
    HelloWorldAsync_sayHelloRequest instance;
    HelloWorldAsync_sayHelloTask *task = NULL;
    HelloWorldAsync_sayHelloRequestUtils::setTypeData(instance, name);
    task = new HelloWorldAsync_sayHelloTask(obj, this);
    retcode = sayHello_Service->executeAsync(&instance, task, getTimeout());
    
    switch (retcode)
    {
        case eProsima::RPCDDS::CLIENT_INTERNAL_ERROR:
            throw eProsima::RPCDDS::ClientInternalException("Error in client side");
            break;
        case eProsima::RPCDDS::NO_SERVER:
             throw eProsima::RPCDDS::ServerNotFoundException("Cannot connect to the server");
             break;
    }
}