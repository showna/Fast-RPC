/* $Id$   *
 * (c) Copyright, eProsima, 2009.                                          *
 * All rights reserved.                                                    *    
 *                                                                         *
 * No duplications, whole or partial, manual or electronic, may be made    *
 * without express written permission.  Any such copies, or                *
 * revisions thereof, must display this notice unaltered.                  *
 * This code contains trade secrets of                                     *
 * eProsima (Proyectos y Sistemas de Mantenimiento S.L.)                   *
 *                                                                         *
 * modification history                                                    *
 * --------------------                                                    *
 * 1.0,27ene10,RodM Created                                                *
 * =====================================================================   *
 */

#if defined(TName) && defined(TDataWriter) && defined(TDataReader) &&     \
    defined(TDataRequestTypeSupport) && defined(TDataReplyTypeSupport) && \
    defined(TData)

#define concatenate(A, B)  A ## B

#define TData_Request(TData) concatenate(TData,Request)
#define TDataRequest TData_Request(TData)
#define TData_Reply(TData) concatenate(TData,Reply)
#define TDataReply TData_Reply(TData)


TName::TName(const char *rpcName, DDSRPC::Server* server, const char *requestTypeName,
        const char *requestQosLibrary, const char *requestQosProfile, const char *replyTypeName,
        const char *replyQosLibrary, const char *replyQosProfile,
        DDSRPC::fExecFunction execFunction, DDS::DomainParticipant *serverParticipant) :
        DDSRPC::ServerRPC(rpcName, server, requestTypeName, requestQosLibrary,
                            requestQosProfile, replyTypeName, replyQosLibrary, replyQosProfile,
                            execFunction, serverParticipant)
{
	replyFooDataWriter    = TDataWriter::narrow(m_replyDataWriter);
	requestFooDataReader  = TDataReader::narrow(m_requestDataReader);
}

TName::~TName()
{
}

int TName::sendReply(void *request, void* reply,  DDSRPC::ReturnMessage errorMessage)
{
    int returnedValue = -1;
    TDataReply   *replyData   = reply != NULL ? (TDataReply*)reply : TDataReplyTypeSupport::create_data();
    TDataRequest *requestData = (TDataRequest*)request;
	//CHECK
    unsigned int *serverServiceId = getServerId();

    if(replyData != NULL)
    {
        if(requestData != NULL)
        {
            replyData->serverServiceId[0] = serverServiceId[0];
            replyData->serverServiceId[1] = serverServiceId[1];
            replyData->serverServiceId[2] = serverServiceId[2];
            replyData->serverServiceId[3] = serverServiceId[3];
			replyData->clientServiceId[0] = requestData->clientServiceId[0];
			replyData->clientServiceId[1] = requestData->clientServiceId[1];
			replyData->clientServiceId[2] = requestData->clientServiceId[2];
			replyData->clientServiceId[3] = requestData->clientServiceId[3];
			replyData->numSec = requestData->numSec;
			replyData->ddscsRetCode = errorMessage;

			if(replyFooDataWriter->write(*replyData, DDS::HANDLE_NIL) == DDS::RETCODE_OK)
			{
				returnedValue = 0;
			}
        }
        else
        {
            printf("ERROR <sendReply>: Bad parameter (replyData)\n");
        }
    }
    else
    {
        printf("ERROR<sendReply>: Bad parameter (requestData)\n");
    }
    return returnedValue;
}

void TName::deleteRequestData(void *request)
{
	TDataRequest *requestData = (TDataRequest*)request;
	
	if(requestData != NULL)
	{
		TDataRequestTypeSupport::delete_data(requestData);
	}
	else
	{
		printf("ERROR<sendReply>: Bad parameter (request)\n");
	}
}


void TName::on_data_available(DDS::DataReader* reader)
{
    DDS::SampleInfo info;
    TDataRequest *data = TDataRequestTypeSupport::create_data();
    
    while(data != NULL && requestFooDataReader->take_next_sample(*data, info) == DDS::RETCODE_OK)
    {
        if(info.valid_data == DDS::BOOLEAN_TRUE){
			m_server->schedule(getExecFunction(), data, this);
			data = TDataRequestTypeSupport::create_data();
		}
	}
	if(data != NULL){
		TDataRequestTypeSupport::delete_data(data);
	}
}



#undef concatenate

#undef TData_Request
#undef TDataRequest
#undef TData_Reply
#undef TDataReply

#endif
