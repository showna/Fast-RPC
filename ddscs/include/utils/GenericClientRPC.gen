/* $Id$   *
 * (c) Copyright, eProsima, 2009.                                          *
 * All rights reserved.                                                    *    
 *                                                                         *
 * No duplications, whole or partial, manual or electronic, may be made    *
 * without express written permission.  Any such copies, or                *
 * revisions thereof, must display this notice unaltered.                  *
 * This code contains trade secrets of                                     *
 * eProsima (Proyectos y Sistemas de Mantenimiento S.L.)                   *
 *                                                                         *
 * modification history                                                    *
 * --------------------                                                    *
 * 1.0,27ene10,RodM Created                                                *
 * =====================================================================   *
 */

#if defined(TName) && defined(TDataWriter) && defined(TDataReader) && \
    defined(TDataTypeSupport) && defined(TData) && defined(TDataSeq)
    
#define concatenate(A, B)  A ## B

#define TData_Request(TData) concatenate(TData,Request)
#define TDataRequest TData_Request(TData)
#define TData_RequestTypeSupport(TData) concatenate(TData,RequestTypeSupport)
#define TDataRequestTypeSupport TData_RequestTypeSupport(TData)
#define TData_Reply(TData) concatenate(TData,Reply)
#define TDataReply TData_Reply(TData)

#define XCLASS_NAME_DEFINITION(ClassName) CLASS_NAME_DEFINITION(ClassName)
#define CLASS_NAME_DEFINITION(ClassName) const char* const ClassName::CLASS_NAME = #ClassName

XCLASS_NAME_DEFINITION(TName);

TName::TName(const char *rpcName, const char *requestTypeName,
        const char *requestQosLibrary, const char *requestQosProfile,
#ifndef IS_ONEWAY
        const char *replyTypeName, const char *replyQosLibrary,
        const char *replyQosProfile,
#endif
        eProsima::DDSRPC::Client *client) :
        eProsima::DDSRPC::ClientRPC(rpcName, requestTypeName, requestQosLibrary, requestQosProfile,
#ifndef IS_ONEWAY
        replyTypeName, replyQosLibrary, replyQosProfile,
#else
        NULL, NULL, NULL,
#endif
        client)
{
	requestDataWriter = TDataWriter::narrow(m_requestDataWriter);
#ifndef IS_ONEWAY
	replyDataReader   = TDataReader::narrow(m_replyDataReader);
#endif
}

TName::~TName()
{
}

int TName::registerInstance(void *data)
{
    int returnedCode = -1;
     
    if(requestDataWriter != NULL)
    {    
        m_ih = requestDataWriter->register_instance(*((TDataRequest*)data));
        
        if(!DDS_InstanceHandle_is_nil(&m_ih))
            returnedCode = 0;
    }
    
    return returnedCode;
}

DDS::ReturnCode_t TName::write(void *data)
{
	DDS::ReturnCode_t retCode = DDS::RETCODE_ERROR;
	
	if(requestDataWriter != NULL){
		retCode = requestDataWriter->write(*((TDataRequest*)data), m_ih);
	}
	return retCode;
}

eProsima::DDSRPC::ReturnMessage TName::takeReply(void *reply, DDS::QueryCondition *query)
{
    eProsima::DDSRPC::ReturnMessage value = eProsima::DDSRPC::CLIENT_ERROR;
#ifndef IS_ONEWAY
    const char* const METHOD_NAME = "takeReply";
    DDS::SampleInfoSeq infoSeq;
	TDataSeq dataSeq;

	if(reply != NULL && query != NULL)
	{
	    DDS::ReturnCode_t retcode = replyDataReader->take_w_condition(dataSeq, infoSeq, DDS::LENGTH_UNLIMITED, query);
	    
		if(retcode == DDS::RETCODE_OK)
		{
		    if(dataSeq.length() == 1)
		    {
				if (infoSeq[0].valid_data)
				{
					retcode = TDataTypeSupport::copy_data((TDataReply*)reply, &dataSeq[0]);
					value = eProsima::DDSRPC::OPERATION_SUCCESSFUL;
				}
		    }
		    else
		    {
				printf("ERROR<%s::%s>: Sequence of replies is not supported.\n", CLASS_NAME, METHOD_NAME);
		    }
		    
		    retcode = replyDataReader->return_loan(dataSeq, infoSeq);
		}
		else if(retcode == DDS::RETCODE_NO_DATA)
		{
			printf("ERROR<%s::%s>: no data.\n", CLASS_NAME, METHOD_NAME);
			value = eProsima::DDSRPC::SERVER_TIMEOUT;
		}
		else
		{
			printf("ERROR<%s::%s>: take error %d\n", CLASS_NAME, METHOD_NAME, retcode);
		}
	}
	else
	{
		printf("ERROR<%s::%s>: bad parameteres\n", CLASS_NAME, METHOD_NAME);
	}
#endif
	
	return value;
}

#undef concatenate

#undef TData_Request
#undef TDataRequest
#undef TData_RequestTypeSupport
#undef TDataRequestTypeSupport
#undef TData_Reply
#undef TDataReply

#endif
